{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Learning Graphs","text":"<p>Welcome to the website for Learning Graphs.  Learning Graphs are concept dependency graphs that are used to:</p> <ol> <li>Understand the important concepts in a course and their dependencies</li> <li>Suggest learning paths to achieve learning objectives</li> <li>Serve as the core data structure for hyper-personalization of lesson plans by generative AI agents.</li> </ol> <p>Please see the About This Site for more details.</p> <p>Please contact me on LinkedIn</p> <p>Thanks! - Dan</p>"},{"location":"about/","title":"About the Learning Graphs Website","text":"<p>The goal of this website is to enable teaching the concepts around Learning Graphs.  It was inspired by the cyberpunk science fiction novel Diamond Age by Neal Stephenson.  In this novel, a child uses a tablet-like device that customizes stories to the needs of the child.  This form of highly-customized learning is our goal.  We believe that learning graphs are the core data structure that these intelligent learning agents will be built on.</p> <p>Learning Graphs are concept dependency graphs that are used to:</p> <ol> <li>Understand the important concepts in a course and their dependencies</li> <li>Suggest learning paths to achieve learning objectives</li> <li>Serve as the core data structure for hyper-personalization of lesson plans by generative AI agents.</li> </ol>"},{"location":"about/#course-learning-objectives","title":"Course Learning Objectives","text":"<p>Here are 10 learning objectives for a course on learning Concept Dependency Graphs (CDGs) using Bloom's Taxonomy, aligned with the use of Generative AI (GenAI) for analyzing course content, creating concept taxonomies, visualizing, editing, and personalizing lesson plans:</p>"},{"location":"about/#remembering","title":"Remembering:","text":"<ol> <li> <p>Identify the basic structure of Concept Dependency Graphs (CDGs) used to model concepts and their dependencies in a course.</p> </li> <li> <p>Example: Define the nodes and edges in a CDG and recognize them in different graphical representations.</p> </li> </ol>"},{"location":"about/#understanding","title":"Understanding:","text":"<ol> <li> <p>Explain how CDGs represent the relationships between course concepts and how they suggest learning paths based on these dependencies.</p> </li> <li> <p>Example: Describe how prerequisite concepts are connected to higher-level concepts within a CDG.</p> </li> </ol>"},{"location":"about/#applying","title":"Applying:","text":"<ol> <li> <p>Use Generative AI to generate concepts lists or use NLP frameworks to extract key concepts from course materials and generate a list of vertices (nodes) for building a CDG.</p> </li> <li> <p>Example: Apply AI tools to analyze a syllabus or textbook and identify core concepts.</p> </li> <li> <p>Apply vis.js (or similar tools) to visualize a Concept Dependency Graph for a given set of concepts and dependencies.</p> </li> <li> <p>Example: Use vis.js to create an interactive graph of course concepts and their dependencies.</p> </li> </ol>"},{"location":"about/#analyzing","title":"Analyzing:","text":"<ol> <li> <p>Analyze concept relationships using Generative AI to discover hidden dependencies that may not be immediately obvious from the course materials.</p> </li> <li> <p>Example: Use an AI agent to uncover indirect concept dependencies based on patterns found in text data.</p> </li> </ol>"},{"location":"about/#evaluating","title":"Evaluating:","text":"<ol> <li> <p>Evaluate the quality of a generated CDG in terms of completeness, accuracy, and alignment with learning objectives.</p> </li> <li> <p>Example: Critically assess a CDG created by AI for coverage of all key topics and concept dependencies.</p> </li> <li> <p>Assess personalized learning paths generated from a CDG, ensuring they meet the individual learning objectives of diverse student profiles.</p> </li> <li> <p>Example: Review AI-generated personalized lesson plans for different student backgrounds and adjust if needed.</p> </li> </ol>"},{"location":"about/#creating","title":"Creating:","text":"<ol> <li> <p>Use Generative AI to automatically generate a concept taxonomy for a course, organizing concepts into hierarchical categories that represent broader topics.</p> </li> <li> <p>Example: Create a hierarchical taxonomy of concepts in a data structures course using AI tools.</p> </li> <li> <p>Edit a CDG interactively to improve learning pathways, adding or removing dependencies between concepts based on AI suggestions or instructor insights.</p> </li> <li> <p>Example: Modify a CDG for a calculus course by adding missing concepts or removing unnecessary dependencies.</p> </li> <li> <p>Design intelligent AI agents that use CDGs to generate hyper-personalized lesson plans, adapting to each student's learning progress and needs.</p> </li> <li> <p>Example: Build an AI system that integrates with a Learning Management System (LMS) to continuously update personalized learning paths based on the student's mastery of concepts.</p> </li> </ol> <p>Each of these objectives integrates various levels of Bloom's Taxonomy (from remembering and understanding basic concepts to applying, analyzing, evaluating, and creating new knowledge) while leveraging Generative AI and CDGs to enhance the learning process.</p>"},{"location":"checklist/","title":"Site Checklist","text":"<ol> <li>Customize the fields in your mkdocs.yml file</li> <li>Configure Google Analytics to use the right site ID</li> <li>Make sure that your .gitignore file includes the <code>site</code> directory</li> <li>Test the build</li> <li>Make sure the Edit button appears</li> <li>Make sure that code color heightening renders correctly</li> <li>run <code>git config advice.addIgnoredFile false</code></li> </ol>"},{"location":"contact/","title":"Contact","text":"<p>Please contact me on LinkedIn</p> <p>Thanks! - Dan</p>"},{"location":"course-description/","title":"Course Description","text":"<p>Title: Customizing Learning Materials with Intelligent Agents</p> <p>In this course, we will learn how on-line content can be generated or quickly customized to the needs of individuals or small groups of students.  We begin with a discussion of learning concepts and the use of concept dependency graphs (CDGs) to model these concepts.  We then show how generative AI tools can be used to generate these concepts or review existing concepts graphs for suitability of learning objectives.  We then describe the process of creating taxonomies and ontologies that can be used with CDGs.  We cover topics of abstraction, clustering and graph algorithms such as graph traversal, search and dependency analysis.  Next we cover the topic of tools to visualize and navigate CDG and explore tools such as vis.js for visualizing CDGs.  Finally, we show how these data structures and algorithms are used together with intelligent agents to customize complex lesson plans for students.</p> <p>Prerequisites: </p> <p>Student should have access to the internet and be familiar with using a web browser and search engines.  Students should also have access to a generative AI tool such as ChatGPG.</p> <p>It is helpful but not required for students should have a background in data structures, teaching theory, lesson plans, curriculum development processes.</p>"},{"location":"glossary/","title":"Glossary of Terms","text":""},{"location":"glossary/#adaptive-learning","title":"Adaptive Learning","text":"<p>A method of delivering personalized learning experiences by dynamically adjusting the content, pace, and instructional approach in response to an individual learner's performance, needs, and preferences.</p> <p>Example: An adaptive learning system uses a concept graph to create customized content for a student. After analyzing the student\u2019s responses to assessment questions, the system identifies specific areas where the student needs more practice. Based on the student's performance and the relationships between concepts in the graph, it selects appropriate materials, such as videos, exercises, or explanations, focusing on strengthening the weaker concepts before advancing to more complex topics. The system continually updates the content based on the student's progress.</p>"},{"location":"glossary/#agent","title":"Agent","text":"<p>An autonomous entity capable of perceiving its environment, processing inputs, and taking actions to achieve specific goals or objectives, often with the ability to adapt or learn from experience.</p> <p>Example:  An intelligent agent in an educational platform uses a learning graph to create a customized lesson plan for students. Based on the results of the prior week's quiz and a predefined learning objective, the agent identifies key concepts where students struggled and selects activities that reinforce those concepts. The lesson plan adapts to each student's individual learning needs, ensuring that the content aligns with their current understanding and progress.</p> <ul> <li>Also known as: Intelligent Agent</li> </ul>"},{"location":"glossary/#alternate-label","title":"Alternate Label","text":"<p>A synonym or alternative term used to represent the same concept within a given context, providing additional ways to reference or describe the concept without altering its meaning.</p> <p>Example: In a learning system, alternative labels are used to provide alternate names for learning concepts. For instance, the concept of \"addition\" in mathematics may have alternative labels such as \"summing\" or \"totaling.\" These alternative labels allow students or teachers to reference the same concept using different terminology, accommodating variations in language or teaching style without changing the underlying concept.</p>"},{"location":"glossary/#blooms-taxonomy","title":"Bloom's Taxonomy","text":""},{"location":"glossary/#concept","title":"Concept","text":"<p>A fundamental unit of knowledge, representing an abstract idea or a mental construct that can be described, categorized, and related to other concepts within a domain.</p> <p>Example: In an educational setting, the concept of \"photosynthesis\" represents the process by which plants convert light energy into chemical energy, and it can be related to concepts such as \"sunlight,\" \"chlorophyll,\" and \"carbon dioxide.\"</p>"},{"location":"glossary/#concept-dependency","title":"Concept Dependency","text":"<p>A relationship between two or more concepts where the understanding of one concept is required before another can be fully understood or applied.</p> <p>Example: The concept of \"multiplication\" is dependent on the understanding of \"addition,\" as multiplication is often described as repeated addition. Therefore, \"addition\" is a prerequisite for learning \"multiplication.\"</p>"},{"location":"glossary/#concept-dependency-graph","title":"Concept Dependency Graph","text":"<p>A visual representation of the relationships between concepts, where nodes represent individual concepts and directed edges indicate dependencies between them, showing how the mastery of one concept is necessary before another.</p> <p>Example: In a concept dependency graph for an algebra course, \"solving linear equations\" may depend on the prior understanding of \"basic arithmetic operations\" and \"variables.\" This graph helps to design learning paths for students based on their current knowledge.</p>"},{"location":"glossary/#directed-graph","title":"Directed Graph","text":"<p>A graph consisting of nodes (vertices) connected by edges (arcs) that have a specific direction, indicating a one-way relationship between the nodes.</p> <p>Example: A directed graph representing traffic flow in a city could have intersections as nodes and one-way streets as directed edges, showing how vehicles can travel from one intersection to another.</p>"},{"location":"glossary/#foundational-concepts","title":"Foundational Concepts","text":"<p>Basic or essential concepts that serve as the building blocks for understanding more complex ideas or advanced knowledge within a domain.</p> <p>Example: In mathematics, \"number sense\" and \"basic arithmetic\" are foundational concepts for understanding more advanced topics such as algebra and calculus.</p>"},{"location":"glossary/#generative-ai","title":"Generative AI","text":"<p>A type of artificial intelligence capable of producing new content, such as text, images, or other data, by learning patterns from existing data and generating outputs that follow those patterns.</p> <p>Example: A generative AI model can create personalized learning materials by analyzing a student's previous responses and generating explanations, questions, or study guides tailored to their learning progress.</p>"},{"location":"glossary/#hyper-personalization","title":"Hyper-Personalization","text":"<p>The process of creating highly individualized experiences or content by leveraging advanced data analysis and machine learning to tailor recommendations, content, and interactions based on unique characteristics of the user.</p> <p>Example: In an online learning platform, hyper-personalization is used to generate lesson plans based on a student's learning preferences, quiz performance, and real-time concept mastery, creating a unique learning path for each student.</p>"},{"location":"glossary/#iso-definition","title":"ISO Definition","text":"<p>A term definition is considered to be consistent with ISO/IEC 11179 metadata registry guideline if it meets the following criteria:</p> <ol> <li>Precise</li> <li>Concise</li> <li>Distinct</li> <li>Non-circular</li> <li>Unencumbered with business rules</li> </ol>"},{"location":"glossary/#journey-map","title":"Journey Map","text":"<p>A visual or structured representation of an individual's experience as they move through a sequence of steps, interactions, or stages to achieve a specific goal, often used to identify touchpoints, challenges, and opportunities for improvement.</p> <p>Example: A journey map for a student's learning process can be derived from a learning concept graph. For instance, the graph shows the required concepts to master \"calculus,\" such as \"basic arithmetic\" and \"algebra.\" A journey map can be created that outlines the student's progression through these concepts, highlighting key milestones, struggles, and recommended interventions at each stage to ensure the successful understanding of calculus.</p> <p>4o</p>"},{"location":"glossary/#learning-graph","title":"Learning Graph","text":"<p>A network graph that stores learning Concepts and their dependencies.</p> <p>Learning graphs are a type of Directed Graphs where every node is a learning Concept and every edge is a concept dependency or prerequisite.</p>"},{"location":"glossary/#learning-management-system-lms","title":"Learning Management System (LMS)","text":"<p>A software platform designed to deliver, manage, and track educational content and activities, enabling learners to access courses, assessments, and other instructional resources, while providing tools for instructors to monitor progress and performance.</p> <p>Example: An LMS can use a learning graph to create customized lesson plans by analyzing a student's performance on past quizzes and identifying gaps in their understanding. For example, if a student demonstrates a weak grasp of \"fractions\" in a math course, the LMS can automatically adjust the lesson plan by offering additional exercises, videos, or tutorials on that specific concept before progressing to more advanced topics like \"algebra.\" This personalized approach ensures that each student follows a learning path tailored to their individual needs.</p>"},{"location":"glossary/#learning-objective","title":"Learning Objective","text":"<p>A specific, measurable goal that defines what a learner should know or be able to do by the end of a lesson, course, or training program.</p> <p>Example: A learning objective for a biology class might be: \"Students will be able to explain the process of cellular respiration and identify its stages.\"</p>"},{"location":"glossary/#learning-path","title":"Learning Path","text":"<p>A structured sequence of learning activities, materials, or modules designed to guide a learner through progressively more advanced content to achieve a specific learning goal.</p> <p>Example: A learning path for mastering algebra might start with basic arithmetic, followed by lessons on solving equations, and then advance to systems of equations and quadratic functions.</p>"},{"location":"glossary/#node-group","title":"Node Group","text":"<p>A collection of interconnected nodes within a graph that share common characteristics or relationships, often treated as a unit for analysis or visualization.</p> <p>Example: In a concept dependency graph, a node group could represent all the foundational concepts needed for understanding calculus, such as \"algebra,\" \"trigonometry,\" and \"functions.\"</p> <ul> <li>Also known as: Cluster</li> </ul>"},{"location":"glossary/#preferred-label","title":"Preferred Label","text":"<p>The preferred name of a Concept.</p> <p>In general, a concept has one and only one preferred name per language such as English, but a Concept may have many alternate labels.</p> <p>Within a learning graph, no two Concepts should have the same preferred name.</p>"},{"location":"glossary/#skos","title":"SKOS","text":"<p>A W3C standard for representing structured knowledge in a simple, machine-readable format, allowing for the sharing and linking of controlled vocabularies, taxonomies, thesauri, and other knowledge organization systems across different systems and applications.</p> <p>Example: SKOS can be used to exchange learning graphs by encoding the relationships between educational concepts as a set of SKOS concepts and properties. For instance, a graph that shows the dependency between \"basic arithmetic,\" \"algebra,\" and \"calculus\" can be expressed using SKOS, with \"broader\" and \"narrower\" properties to define the hierarchy and concept relationships. This allows different educational platforms to share and reuse the same structure for organizing learning materials.</p> <p>Note that SKOS is ideal for storing taxonomies and ontologies, but is not use for showing learning order dependencies.</p> <ul> <li>Also Known as: Simple Knowledge Organization System</li> </ul>"},{"location":"glossary/#touchpoint","title":"Touchpoint","text":"<p>An interaction or moment of engagement between a learner and a learning management system (LMS), typically associated with key stages in the learning process where progress, feedback, or guidance is provided.</p> <p>Example: In a learning management system built around a learning graph, touchpoints occur when a student completes a quiz, views instructional content, or seeks help on a specific concept. By analyzing these touchpoints, instructors can identify where students frequently encounter difficulties or disengage. Touchpoint analysis might reveal that many students struggle with \"fractions\" before advancing to \"algebra,\" allowing instructors to redesign the course by adding additional resources or alternative explanations at that critical stage, improving student success. ```</p>"},{"location":"how-we-built-this-site/","title":"How We Built This Site","text":"<p>This page describes how we built this website and some of  the rationale behind why we made various design choices.</p>"},{"location":"how-we-built-this-site/#python","title":"Python","text":"<p>MicroSims are about how we use generative AI to create animations and simulations.  The language of AI is Python.  So we wanted to create a site that could be easily understood by Python developers.</p>"},{"location":"how-we-built-this-site/#mkdocs-vs-docusaurus","title":"Mkdocs vs. Docusaurus","text":"<p>There are two main tools used by Python developers to write documentation: Mkdocs and Docusaurus.  Mkdocs is easier to use and more popular than Docusaurus. Docusaurus is also optimized for single-page applications. Mkdocs also has an extensive library of themes and plugins. None of us are experts in JavaScript or React. Based on our ChatGPT Analysis of the Tradeoffs we chose mkdocs for this site management.</p>"},{"location":"how-we-built-this-site/#github-and-github-pages","title":"GitHub and GitHub Pages","text":"<p>GitHub is a logical choice to store our  site source code and documentation.  GitHub also has a Custom GitHub Action that does auto-deployment if any files on the site change. We don't currently have this action enabled, but other teams can use this feature if they don't have the ability to do a local build with mkdocs.</p> <p>GitHub also has Issues,  Projects and releases that we can use to manage our bugs and tasks.</p> <p>The best practice for low-cost websites that have public-only content is GitHub Pages. Mkdocs has a command (<code>mkdocs gh-deploy</code>) that does deployment directly to GitHub Pages.  This was an easy choice to make.</p>"},{"location":"how-we-built-this-site/#github-clone","title":"GitHub Clone","text":"<p>If you would like to clone this repository, here are the commands:</p> <pre><code>mkdir projects\ncd projects\ngit clone https://github.com/dmccreary/microsims\n</code></pre>"},{"location":"how-we-built-this-site/#after-changes","title":"After Changes","text":"<p>After you make local changes you must do the following:</p> <pre><code># add the new files to a a local commit transaction\ngit add FILES\n# Execute the a local commit with a message about what and why you are doing the commit\ngit commit -m \"comment\"\n# Update the central GitHub repository\ngit push\n</code></pre>"},{"location":"how-we-built-this-site/#material-theme","title":"Material Theme","text":"<p>We had several options when picking a mkdocs theme:</p> <ol> <li>Mkdocs default</li> <li>Readthedocs</li> <li>Third-Party Themes See Ranking</li> </ol> <p>The Material Theme had 16K stars.  No other theme had over a few hundred. This was also an easy design decision.</p> <p>One key criterial was the social Open Graph tags so that when our users post a link to a simulation, the image of the simulation is included in the link.  Since Material supported this, we used the Material theme. You can see our ChatGPT Design Decision Analysis if you want to check our decision process.</p>"},{"location":"how-we-built-this-site/#enable-edit-icon","title":"Enable Edit Icon","text":"<p>To enable the Edit icon on all pages, you must add the edit_uri and the content.action.edit under the theme features area.</p> <pre><code>edit_uri: edit/master/docs/\n</code></pre> <pre><code>    theme:\n        features:\n            - content.action.edit\n</code></pre>"},{"location":"how-we-built-this-site/#conda-vs-venv","title":"Conda vs VENV","text":"<p>There are two choices for virtual environments.  We can use the native Python venv or use Conda.  venv is simle but is only designed for pure Python projects.  We imagine that this site could use JavaScript and other langauges in the future, so we picked Conda. There is nothing on this microsite that prevents you from using one or the other.  See the ChatGPT Analysis Here.</p> <p>Here is the conda script that we ran to create a new mkdocs environment that also supports the material social imaging libraries.</p> <pre><code>conda deactivate\nconda create -n mkdocs python=3\nconda activate mkdocs\npip install mkdocs \"mkdocs-material[imaging]\"\n</code></pre>"},{"location":"how-we-built-this-site/#mkdocs-commands","title":"Mkdocs Commands","text":"<p>There are three simple mkdoc commands we use.</p>"},{"location":"how-we-built-this-site/#local-build","title":"Local Build","text":"<pre><code>mkdocs build\n</code></pre> <p>This builds your website in a folder called <code>site</code>.  Use this to test that the mkdocs.yml site is working and does not have any errors.</p>"},{"location":"how-we-built-this-site/#run-a-local-server","title":"Run a Local Server","text":"<pre><code>mkdocs serve\n</code></pre> <p>This runs a server on <code>http://localhost:8000</code>. Use this to test the display formatting locally before you push your code up to the GitHub repo.</p> <pre><code>mkdoc gh-deploy\n</code></pre> <p>This pushes everything up to the GitHub Pages site. Note that it does not commit your code to GitHub.</p>"},{"location":"how-we-built-this-site/#mkdocs-material-social-tags","title":"Mkdocs Material Social Tags","text":"<p>We are using the Material Social tags.  This is a work in progress!</p> <p>Here is what we have learned.</p> <ol> <li>There are extensive image processing libraries that can't be installed with just pip.  You will need to run a tool like brew on the Mac to get the libraries installed.</li> <li>Even after <code>brew</code> installs the libraries, you have to get your environment to find the libraries.  The only way I could get that to work was to set up a local UNIX environment variable.</li> </ol> <p>Here is the brew command that I ran:</p> <pre><code>brew install cairo freetype libffi libjpeg libpng zlib\n</code></pre> <p>I then had to add the following to my ~/.zshrc file:</p> <pre><code>export DYLD_FALLBACK_LIBRARY_PATH=/opt/homebrew/lib\n</code></pre> <p>Note that I am running on a Mac with Apple silicon.  This means that the image libraries that brew downloads must be specific to the Mac Arm instruction set.</p> <ul> <li>Cover images for blog post #4364</li> <li>Discussion on overriding the Social Card Image</li> </ul>"},{"location":"license/","title":"Creative Commons License","text":"<p>All content in this repository is governed by the following license agreement:</p>"},{"location":"license/#license-type","title":"License Type","text":"<p>Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0 DEED)</p>"},{"location":"license/#link-to-license-agreement","title":"Link to License Agreement","text":"<p>https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en</p>"},{"location":"license/#your-rights","title":"Your Rights","text":"<p>You are free to:</p> <ul> <li>Share \u2014 copy and redistribute the material in any medium or format</li> <li>Adapt \u2014 remix, transform, and build upon the material</li> </ul> <p>The licensor cannot revoke these freedoms as long as you follow the license terms.</p>"},{"location":"license/#restrictions","title":"Restrictions","text":"<ul> <li>Attribution \u2014 You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use.</li> <li>NonCommercial \u2014 You may not use the material for commercial purposes.</li> <li>ShareAlike \u2014 If you remix, transform, or build upon the material, you must distribute your contributions under the same license as the original.</li> <li>No additional restrictions \u2014 You may not apply legal terms or technological measures that legally restrict others from doing anything the license permits.</li> </ul> <p>Notices</p> <p>You do not have to comply with the license for elements of the material in the public domain or where your use is permitted by an applicable exception or limitation.</p> <p>No warranties are given. The license may not give you all of the permissions necessary for your intended use. For example, other rights such as publicity, privacy, or moral rights may limit how you use the material.</p> <p>This deed highlights only some of the key features and terms of the actual license. It is not a license and has no legal value. You should carefully review all of the terms and conditions of the actual license before using the licensed material.</p>"},{"location":"references/","title":"Site References","text":"<ol> <li>mkdocs - https://www.mkdocs.org/ - this is our tool for building the website.  It converts Markdown into HTML in the <code>site</code> directory.</li> <li>mkdocs material theme - https://squidfunk.github.io/mkdocs-material/ - this is the theme for our site.  The theme adds the user interface elements that give our site the look and feel.  It also has the features such as social cards.</li> <li>GitHub Pages - https://pages.github.com/ - this is the free tool for hosting public websites created by mkdocs</li> <li>Markdown - https://www.mkdocs.org/user-guide/writing-your-docs/#writing-with-markdown - this is the format we use for text.  It allows us to have headers, lists, tables, links and images without learning HTML.</li> <li>Deploy Mkdocs GitHub Action - https://github.com/marketplace/actions/deploy-mkdocs - this is the tool we use to automatically build our site after edits are checked in with Git.</li> <li>Git Book - https://git-scm.com/book/en/v2 - a useful book on Git.  Just read the first two chapters to learn how to check in new code.</li> <li>Conda - https://conda.io/ - this is a command line tool that keeps our Python libraries organized for each project.</li> <li>VS Code - https://code.visualstudio.com/ - this is the integrated development environment we use to mange the files on our website.</li> <li>Markdown Paste - https://marketplace.visualstudio.com/items?itemName=telesoho.vscode-markdown-paste-image - this is the VS code extension we use to make sure we keep the markdown format generated by ChatGPT.</li> </ol>"},{"location":"case-studies/","title":"Case Studies","text":""},{"location":"case-studies/#undergraduate-circuits-course","title":"Undergraduate Circuits Course","text":""},{"location":"case-studies/#teaching-computational-thinking-with-micropython","title":"Teaching Computational Thinking with MicroPython","text":"<p>MicroPython Learning Graph</p>"},{"location":"case-studies/low-latency/","title":"Creating Low-Latency Applications","text":""},{"location":"case-studies/low-latency/#sample-prompt","title":"Sample Prompt","text":"<pre><code>Create a list of concepts that might be taught in a class on\nbuilding low-latency applications. These are applications that\nmust return results in a short window of time, typically 100 milliseconds.\nList Concepts about the infrastructure necessary to support\nthese types of applications and how the cloud may not be\nthe right way to solve these problems. List the concepts\nin setting up virtual private networks and in-memory graph\ndatabases to execute fast business logic.\n</code></pre> <p>ChatGPT</p> <p>Thought for 46 seconds</p> <p>Concepts Covered in a Class on Building Low-Latency Applications</p>"},{"location":"case-studies/low-latency/#understanding-latency-fundamentals","title":"Understanding Latency Fundamentals","text":"<ul> <li>Types of Latency: Network, processing, disk I/O, and application latency.</li> <li>Sources of Latency: Hardware limitations, software inefficiencies, network congestion.</li> <li>Measuring Latency: Tools and metrics for assessing performance (e.g., ping, traceroute, profiling).</li> </ul>"},{"location":"case-studies/low-latency/#network-infrastructure-optimization","title":"Network Infrastructure Optimization","text":"<ul> <li>Edge Computing: Processing data closer to the source to reduce latency.</li> <li>Content Delivery Networks (CDNs): Distributing content geographically to minimize access time.</li> <li>Protocol Optimization: Using UDP over TCP when appropriate, implementing QUIC protocol.</li> <li>High-Speed Networking Hardware: Leveraging InfiniBand, RDMA, and low-latency switches.</li> </ul>"},{"location":"case-studies/low-latency/#hardware-considerations-for-low-latency","title":"Hardware Considerations for Low Latency","text":"<ul> <li>High-Performance CPUs and GPUs: Selecting processors with low-latency characteristics.</li> <li>Specialized Hardware: Utilizing FPGAs and ASICs for specific low-latency tasks.</li> <li>Memory Technologies: Employing NVMe and RAM disks to accelerate data access.</li> </ul>"},{"location":"case-studies/low-latency/#software-optimization-techniques","title":"Software Optimization Techniques","text":"<ul> <li>Efficient Algorithms and Data Structures: Choosing optimal methods for speed (e.g., hash tables, tries).</li> <li>Parallelism and Concurrency: Implementing multithreading and asynchronous processing.</li> <li>Code Profiling and Performance Tuning: Identifying bottlenecks using profiling tools.</li> <li>Compiler Optimizations: Utilizing compiler flags and settings to enhance performance.</li> </ul>"},{"location":"case-studies/low-latency/#in-memory-computing-strategies","title":"In-Memory Computing Strategies","text":"<ul> <li>In-Memory Databases: Storing data in RAM for rapid access (e.g., Redis, Memcached).</li> <li>Caching Mechanisms: Implementing local and distributed caches to reduce data retrieval time.</li> <li>Data Locality: Ensuring data is stored close to the computation resources.</li> </ul>"},{"location":"case-studies/low-latency/#minimizing-external-dependencies","title":"Minimizing External Dependencies","text":"<ul> <li>Reducing API Calls: Limiting reliance on external services that introduce latency.</li> <li>Local Processing: Performing computations locally rather than remotely.</li> <li>Dependency Management: Using lightweight libraries and frameworks.</li> </ul>"},{"location":"case-studies/low-latency/#programming-languages-and-runtime-environments","title":"Programming Languages and Runtime Environments","text":"<ul> <li>Low-Level Languages: Utilizing C, C++, or Rust for fine-grained control over performance.</li> <li>Garbage Collection Tuning: Adjusting JVM or .NET settings to minimize pauses.</li> <li>Real-Time Systems Programming: Writing code for real-time operating systems.</li> </ul>"},{"location":"case-studies/low-latency/#asynchronous-and-non-blocking-io","title":"Asynchronous and Non-Blocking I/O","text":"<ul> <li>Event-Driven Architectures: Leveraging event loops and callbacks.</li> <li>Reactive Programming: Using frameworks like ReactiveX to handle asynchronous data streams.</li> <li>Non-Blocking I/O Libraries: Employing technologies like epoll, kqueue, or IOCP.</li> </ul>"},{"location":"case-studies/low-latency/#time-sensitive-networking-tsn","title":"Time-Sensitive Networking (TSN)","text":"<ul> <li>Deterministic Network Behavior: Ensuring predictable latency through TSN protocols.</li> <li>Quality of Service (QoS): Prioritizing network traffic to meet latency requirements.</li> <li>Network Slicing: Allocating dedicated bandwidth for critical applications.</li> </ul>"},{"location":"case-studies/low-latency/#challenges-with-cloud-solutions","title":"Challenges with Cloud Solutions","text":"<ul> <li>Physical Distance: Latency introduced by the geographical location of data centers.</li> <li>Virtualization Overhead: Delays caused by hypervisors and shared resources.</li> <li>Multi-Tenancy Issues: Performance variability due to other tenants' workloads.</li> <li>Limited Hardware Control: Inability to select or optimize underlying hardware.</li> <li>Network Routing Limitations: Restricted influence over data packet paths.</li> </ul>"},{"location":"case-studies/low-latency/#alternatives-to-cloud-computing","title":"Alternatives to Cloud Computing","text":"<ul> <li>On-Premises Infrastructure: Building and managing local data centers.</li> <li>Edge Computing Devices: Deploying computation resources at the network edge.</li> <li>Hybrid Models: Combining cloud and local resources for optimal performance.</li> </ul>"},{"location":"case-studies/low-latency/#virtual-private-networks-vpns-setup-and-optimization","title":"Virtual Private Networks (VPNs) Setup and Optimization**","text":"<ul> <li>VPN Fundamentals: Understanding encryption, tunneling protocols, and authentication.</li> <li>Types of VPNs: Site-to-site, remote access, and SSL/TLS-based VPNs.</li> <li>Performance Implications: Evaluating the latency overhead of encryption and tunneling.</li> <li>Protocol Selection: Choosing between IPSec, OpenVPN, WireGuard for low latency.</li> <li>VPN Topologies: Designing mesh or hub-and-spoke networks for efficiency.</li> <li>Optimizing Throughput: Adjusting MTU sizes, leveraging hardware acceleration.</li> <li>Integration with Network Infrastructure: Seamless operation with firewalls, routers, and switches.<ul> <li>Monitoring and Troubleshooting: Tools for assessing VPN performance and diagnosing issues.</li> </ul> </li> </ul>"},{"location":"case-studies/low-latency/#in-memory-graph-databases-for-fast-business-logic","title":"In-Memory Graph Databases for Fast Business Logic","text":"<pre><code>-   **Graph Database Concepts**: Nodes, edges, properties, and graph traversal.\n-   **Advantages of In-Memory Graph Databases**: Speed, efficiency, and real-time analytics.\n-   **Popular In-Memory Graph Databases**: Neo4j (in-memory configurations), RedisGraph, Amazon Neptune.\n-   **Data Modeling**: Representing complex relationships and hierarchies.\n-   **Query Languages**: Using Cypher, Gremlin, or SPARQL for efficient data retrieval.\n-   **Performance Tuning**: Indexing strategies, query optimization, and caching results.\n-   **Distributed Graph Processing**: Handling large datasets across multiple nodes.\n-   **Transactional Support**: Ensuring data integrity with ACID compliance.\n-   **Embedding Business Logic**: Implementing stored procedures and triggers within the database.\n-   **Memory Management**: Strategies for efficient memory usage and garbage collection.\n</code></pre>"},{"location":"case-studies/low-latency/#security-considerations","title":"Security Considerations","text":"<pre><code>-   **Encryption Overhead**: Balancing security needs with performance impacts.\n-   **Secure Coding Practices**: Preventing vulnerabilities that could introduce latency.\n-   **Authentication Mechanisms**: Implementing fast and secure user authentication.\n</code></pre>"},{"location":"case-studies/low-latency/#testing-and-monitoring-low-latency-applications","title":"Testing and Monitoring Low-Latency Applications","text":"<pre><code>-   **Performance Testing Tools**: JMeter, Gatling, and custom benchmarking scripts.\n-   **Real-Time Monitoring**: Utilizing tools like Grafana, Prometheus, or Datadog.\n-   **Logging Best Practices**: Ensuring logging does not adversely affect performance.\n-   **Continuous Optimization**: Iterative testing and tuning based on monitoring data.\n</code></pre>"},{"location":"case-studies/low-latency/#regulatory-and-compliance-implications","title":"Regulatory and Compliance Implications","text":"<pre><code>-   **Data Localization Laws**: Understanding how regulations affect data placement and latency.\n-   **Industry Standards**: Complying with standards like PCI DSS, HIPAA, which may impact design choices.\n</code></pre>"},{"location":"case-studies/low-latency/#case-studies-and-real-world-applications","title":"Case Studies and Real-World Applications","text":"<pre><code>-   **High-Frequency Trading Systems**: Techniques used to achieve microsecond-level latency.\n-   **Real-Time Gaming**: Ensuring minimal lag in multiplayer online games.\n-   **Industrial Automation**: Using low-latency networks for process control systems.\n-   **Internet of Things (IoT)**: Managing latency in sensor networks and smart devices.\n</code></pre>"},{"location":"case-studies/low-latency/#emerging-technologies-and-trends","title":"Emerging Technologies and Trends","text":"<pre><code>-   **5G Networks**: Leveraging increased bandwidth and reduced latency.\n-   **Software-Defined Networking (SDN)**: Dynamically optimizing network paths.\n-   **Artificial Intelligence and Machine Learning**: Real-time data processing at the edge.\n</code></pre> <p>By covering these concepts, the class would equip students with the knowledge and skills to design and implement applications that meet stringent low-latency requirements, while also understanding the limitations and alternatives to traditional cloud-based solutions.</p>"},{"location":"chapters/","title":"Learning Graphs","text":"<ul> <li>Learning Graphs</li> <li>Concepts</li> <li>Bloom's Taxonomy</li> <li>Concept Dependency</li> <li>Concept Taxonomies</li> <li>Displaying Graphs</li> <li>Vis.js</li> <li>Enumerating Concepts</li> <li>Generating Dependencies</li> <li>Generating Taxonomies</li> <li>Dependency Analysis</li> <li>Customizing Lesson Plans</li> <li>LMS Integration</li> <li>Building Intelligent Agents</li> </ul>"},{"location":"chapters/01-learning-graphs/","title":"Learning Graphs","text":"<p>In this chapter, we introduce you to the foundational data structure used by intelligent agents that build customized lesson plans for each student: The Learning Graph.</p>"},{"location":"chapters/01-learning-graphs/#what-are-learning-graphs","title":"What Are Learning Graphs?","text":"<p>Learning graphs are network graph that stores learning Concepts and their dependencies.</p> <p>Learning graphs are a type of Directed Graphs where every node is a learning Concept and every edge is a concept dependency or prerequisite.</p> <p>A Learning Graph is a powerful representation of knowledge used to model the relationships between different learning concepts and their dependencies. This graph-based approach enables a structured, visual way to map out the sequence in which learners need to acquire knowledge, making it particularly effective for hyper-personalized lesson plan generation.</p> <p>In essence, a learning graph is a type of directed graph where every node represents a learning concept, and each directed edge signifies a prerequisite relationship between two concepts. By modeling the learning process as a graph, we can identify the optimal path a learner should follow to master a specific topic.</p>"},{"location":"chapters/01-learning-graphs/#why-learning-graphs-matter","title":"Why Learning Graphs Matter","text":"<p>Learning graphs offer several key advantages when designing personalized learning paths:</p> <ul> <li>Clarity in Concept Dependencies: They make the relationships between concepts explicit, ensuring learners acquire foundational knowledge before advancing to more complex topics.</li> <li>Adaptive Learning Paths: By analyzing the structure of the graph, we can create tailored lesson plans for individual learners, focusing on the gaps in their knowledge while skipping over concepts they've already mastered.</li> <li>Flexibility and Scalability: Learning graphs are highly flexible and can scale across different subjects and educational levels, from elementary school topics to advanced technical subjects.</li> </ul>"},{"location":"chapters/01-learning-graphs/#structure-of-a-learning-graph","title":"Structure of a Learning Graph","text":"<p>A learning graph is composed of two primary elements:</p> <ul> <li>Nodes (Concepts): Each node represents a distinct learning concept. These could range from fundamental principles, like \"Ohm's Law\" in an electrical circuits course, to more complex topics like \"Neural Networks\" in a machine learning course.</li> <li>Edges (Prerequisites): Each directed edge represents a dependency or prerequisite. For example, a concept such as \"Addition\" or \"Subtraction\" must be understood before a learner be confident they understand \"Arithmetic.\"</li> </ul> <p></p> <p> A diagram showing 5-6 nodes connected by directed edges, illustrating a simple learning path where each node depends on the previous one. For instance, concepts related to mathematics, starting with \"Basic Algebra\" leading to \"Linear Equations\" and ending with \"Quadratic Functions.\" </p>"},{"location":"chapters/01-learning-graphs/#types-of-learning-graphs","title":"Types of Learning Graphs","text":"<p>Learning graphs can take on various forms depending on the complexity of the learning domain and the learner's background.</p>"},{"location":"chapters/01-learning-graphs/#linear-graph","title":"Linear Graph**:","text":"<p>In this form, each concept has exactly one prerequisite. This structure is suitable for topics that build incrementally without divergence, such as learning how to assemble a robot where part order is critical. In this lesson, each step depends on the prior step being completed before it can begin.</p> <ol> <li>Open Box</li> <li>Confirm Part List</li> <li>Attach Motor Chassis</li> <li>Attach Wheels to Chassis</li> <li>Attach Battery to Chassis</li> <li>Mount Microcontroller</li> <li>Mount Sensors</li> <li>Connect Microcontroller</li> <li>Upload Code to Microcontroller</li> <li>Test the Robot</li> </ol>"},{"location":"chapters/01-learning-graphs/#branching-graph","title":"Branching Graph","text":"<p>A more complex form where certain concepts can lead to multiple others. For example, mastering \"Statistics\" may be a prerequisite for both \"Data Science\" and \"Machine Learning.\"</p> <p>Example:</p> <ol> <li>Learn Python</li> <li> <p>Use </p> </li> <li> <p>Converging Graph: This graph structure occurs when multiple prerequisite concepts lead to the mastery of a single, more advanced concept. For instance, mastering both \"Trigonometry\" and \"Algebra\" may be required before understanding \"Calculus.\"</p> </li> </ol>"},{"location":"chapters/01-learning-graphs/#figure-suggestion","title":"Figure Suggestion:","text":"<ol> <li>Branching Graph Example: A diagram showing nodes with multiple paths branching out from a single node, illustrating how different branches of learning lead to diverse advanced topics.</li> </ol>"},{"location":"chapters/01-learning-graphs/#practical-applications-of-learning-graphs","title":"Practical Applications of Learning Graphs","text":"<ol> <li> <p>Course Design and Planning: Educators can use learning graphs to map out entire courses, ensuring the logical progression of topics and making it easy to identify areas where students might struggle based on their gaps in prerequisite knowledge.</p> </li> <li> <p>Personalized Learning Paths: In personalized education, learning graphs allow for dynamic adjustment of lesson plans based on an individual's current knowledge. When a learner demonstrates proficiency in a specific concept, they can immediately proceed to the next dependent concept.</p> </li> <li> <p>Assessment and Remediation: Learning graphs are particularly useful in assessment-driven learning environments. By pinpointing exactly where a student is struggling, educators can focus on reinforcing specific concepts without re-teaching the entire curriculum.</p> </li> </ol>"},{"location":"chapters/01-learning-graphs/#leveraging-learning-graphs-in-hypercustomized-lesson-plans","title":"Leveraging Learning Graphs in Hypercustomized Lesson Plans","text":"<p>When creating hypercustomized lesson plans, learning graphs provide the foundational structure to ensure that each student receives the exact lessons they need, in the proper sequence. By identifying where a learner is within the graph, lesson plans can be dynamically generated to either:</p> <ul> <li>Focus on filling gaps in prerequisite knowledge</li> <li>Accelerate the learner through concepts they have already mastered</li> <li>Present appropriate challenges based on the learner's current level</li> </ul> <p>This approach not only enhances learning efficiency but also keeps students engaged by delivering content that is neither too difficult nor too easy.</p>"},{"location":"chapters/01-learning-graphs/#figure-suggestion_1","title":"Figure Suggestion:","text":"<ol> <li>Customized Learning Path: A learning graph with certain nodes highlighted, showing how an individualized lesson path is formed by skipping over mastered concepts and focusing on specific prerequisites.</li> </ol>"},{"location":"chapters/01-learning-graphs/#challenges-in-designing-learning-graphs","title":"Challenges in Designing Learning Graphs","text":"<p>While learning graphs offer great benefits, there are some challenges in creating and maintaining them:</p> <ul> <li> <p>Conceptual Granularity: Deciding the appropriate level of granularity for concepts can be difficult. Too many fine-grained concepts may overcomplicate the graph, while too few might overlook essential nuances in learning.</p> </li> <li> <p>Dynamic Changes: As educational methods and content evolve, learning graphs need to be adaptable to accommodate new concepts or altered dependencies.</p> </li> </ul>"},{"location":"chapters/01-learning-graphs/#conclusion","title":"Conclusion","text":"<p>Learning graphs are an essential tool for structuring educational content and designing hypercustomized lesson plans. By representing concepts and their dependencies as a directed graph, educators can ensure that learners progress through material in an optimal, personalized manner. In the next chapter, we will delve deeper into what constitutes a \"Concept\" and how it plays a role in the overall structure of a learning graph.</p>"},{"location":"chapters/01-learning-graphs/#figure-suggestion_2","title":"Figure Suggestion:","text":"<ol> <li>Advanced Learning Graph: A more detailed network graph with multiple branching paths and dependencies, showing how a complex subject area might be organized in a learning graph format.</li> </ol> <p>4o</p> <p>window.__oai_logHTML?window.__oai_logHTML():window.__oai_SSR_HTML=window.__oai_SSR_HTML||Date.now();requestAnimationFrame((function(){window.__oai_logTTI?window.__oai_logTTI():window.__oai_SSR_TTI=window.__oai_SSR_TTI||Date.now()}))</p>"},{"location":"chapters/02-blooms-taxonomy/","title":"Bloom's Taxonomy","text":"<p> Image credit</p>"},{"location":"chapters/02-blooms-taxonomy/#introduction","title":"Introduction","text":"<p>In education and course learning objective design, Bloom's Taxonomy can be useful in organizing course concepts to achieve specific goals.  Bloom's Taxonomy helps us order concepts clearly.  It teaches the importance of memorization of knowledge first and then later that knowledge to solve problems.  The figure above is a triangle that shows how the lower elements of the triangle should be taught before the higher elements.</p> <p>Bloom's Taxonomy is a framework for categorizing educational goals, developed by Benjamin Bloom and collaborators in 1956 and revised in 2001 to place creation of new artifacts at the top of a pyramid structure. It is widely used in designing learning objectives, assessments, and instructional strategies to promote higher-order thinking. The taxonomy divides learning into multiple levels.</p>"},{"location":"chapters/02-blooms-taxonomy/#domain-1-cognitive-domain-knowledge-based","title":"Domain 1: Cognitive Domain (Knowledge-based)","text":"<p>This is the most widely used part of the taxonomy, focusing on mental skills and knowledge acquisition. It is often represented as a pyramid with six levels of complexity, moving from basic knowledge to higher-order thinking:</p> <ul> <li>Remembering: Recalling facts and basic concepts (e.g., define, list, memorize)</li> <li>Understanding: Explaining ideas or concepts (e.g., describe, explain, summarize)</li> <li>Applying: Using information in new situations (e.g., solve, demonstrate, apply)</li> <li>Analyzing: Breaking information into parts to explore relationships (e.g., compare, contrast, categorize)</li> <li>Evaluating: Making judgments based on criteria (e.g., justify, critique, assess)</li> <li>Creating: Putting elements together to form new ideas or products (e.g., design, construct, develop)</li> </ul>"},{"location":"chapters/02-blooms-taxonomy/#domain-2-affective-domain-attitude-based","title":"Domain 2: Affective Domain (Attitude-based)","text":"<p>This focuses on feelings, emotions, and attitudes, covering how learners internalize and reflect on values.</p> <ul> <li>Receiving: Awareness and willingness to hear</li> <li>Responding: Active participation through reacting or responding</li> <li>Valuing: Recognizing the worth of something</li> <li>Organizing: Integrating values into one's life</li> <li>Characterizing: Acting consistently with a value system</li> </ul>"},{"location":"chapters/02-blooms-taxonomy/#domain-3-psychomotor-domain-skill-based","title":"Domain 3: Psychomotor Domain (Skill-based)","text":"<p>This domain involves physical movement, coordination, and the use of motor skills. While less emphasized in Bloom's original taxonomy, it is important in disciplines that require hands-on tasks.</p> <ul> <li>Perception: Using sensory cues to guide actions</li> <li>Set: Readiness to act</li> <li>Guided Response: Early stages of learning skills</li> <li>Mechanism: Proficiency in performing skills</li> <li>Complex Overt Response: Advanced performance of skills</li> <li>Adaptation: Modifying skills to meet new demands</li> <li>Origination: Creating new artifacts from patterns</li> </ul>"},{"location":"chapters/02-blooms-taxonomy/#purpose","title":"Purpose","text":"<p>Bloom's Taxonomy helps educators design curriculum and assessments that target not just the memorization of facts, but also the development of critical thinking and problem-solving abilities. By moving students through progressively more complex levels of thinking, it ensures a comprehensive approach to learning that includes both foundational knowledge and higher-order thinking skills.</p>"},{"location":"chapters/02-blooms-taxonomy/#using-blooms-taxonomy-to-create-learning-graphs","title":"Using Bloom's Taxonomy To Create Learning Graphs","text":"<p>Bloom's Taxonomy can be a valuable tool in creating a concept dependency graph for courses by organizing the progression of learning objectives in a structured way. A concept dependency graph visualizes how different topics or skills in a course build on each other, guiding the instructional design toward achieving higher levels of learning.</p> <p>Here's how Bloom's Taxonomy can be used in creating such a graph:</p>"},{"location":"chapters/02-blooms-taxonomy/#establish-foundational-concepts-using-lower-levels-of-blooms-taxonomy","title":"Establish Foundational Concepts Using Lower Levels of Bloom's Taxonomy","text":"<ul> <li> <p>Cognitive Levels: Remembering and Understanding     The base of the graph should start with concepts that involve recalling basic facts and understanding fundamental principles. These concepts form the foundation of the course, as students need to acquire knowledge before they can progress to higher-order thinking.</p> <p>Example: In a circuits course, students must first remember Ohm's Law and understand basic components like resistors and capacitors.</p> <ul> <li>Graph Node: \"Ohm's Law (Remember)\"</li> <li>Graph Node: \"Basic Components (Understand)\"</li> <li>Arrows: Indicate that subsequent concepts depend on these foundational ideas.</li> </ul> </li> </ul>"},{"location":"chapters/02-blooms-taxonomy/#link-concepts-with-intermediate-cognitive-levels","title":"Link Concepts with Intermediate Cognitive Levels","text":"<ul> <li> <p>Cognitive Levels: Applying and Analyzing     Once students have the foundation, the graph should show applying knowledge to new situations and analyzing relationships between concepts. This phase introduces the dependency of practical tasks and critical thinking.</p> <p>Example: Applying Ohm's Law in circuit analysis and analyzing how changing a resistor affects the overall circuit.</p> <ul> <li>Graph Node: \"Apply Ohm's Law to Circuits (Apply)\"</li> <li>Graph Node: \"Analyze Circuit Behavior (Analyze)\"</li> <li>Arrows: Indicate that students cannot analyze circuits without first applying the knowledge of Ohm's Law.</li> </ul> </li> </ul>"},{"location":"chapters/02-blooms-taxonomy/#introduce-advanced-concepts-using-higher-levels","title":"Introduce Advanced Concepts Using Higher Levels","text":"<ul> <li> <p>Cognitive Levels: Evaluating and Creating     The top levels of Bloom's Taxonomy, evaluating and creating, should come later in the graph. These concepts rely heavily on mastery of earlier stages and involve judging, designing, or constructing new knowledge or solutions. This is where students synthesize their learning into creative or evaluative tasks.</p> <p>Example: Designing a complete circuit based on given requirements or evaluating the efficiency of different circuit designs.</p> <ul> <li>Graph Node: \"Evaluate Circuit Designs (Evaluate)\"</li> <li>Graph Node: \"Create a New Circuit (Create)\"</li> <li>Arrows: Show the dependency on earlier stages of analysis and application.</li> </ul> </li> </ul>"},{"location":"chapters/02-blooms-taxonomy/#visual-structure-layering-the-concepts","title":"Visual Structure: Layering the Concepts","text":"<ul> <li> <p>Left-to-Right Progression     In the concept dependency graph, start with foundational concepts on the left (Remembering, Understanding), and place more advanced concepts on the right (Applying, Analyzing, Evaluating, Creating). This progression aligns with Bloom's Taxonomy and clearly shows how mastery at one level enables the next.</p> <ul> <li>Foundational concepts (Remember, Understand) -&gt; Intermediate concepts (Apply, Analyze) -&gt; Advanced concepts (Evaluate, Create).</li> </ul> </li> <li> <p>Arrows and Dependencies     Use arrows to indicate dependencies, showing that students must master simpler concepts before moving on to more complex ones. This makes the learning path explicit and encourages scaffolding in teaching methods.</p> </li> </ul>"},{"location":"chapters/02-blooms-taxonomy/#supporting-affective-and-psychomotor-domains","title":"Supporting Affective and Psychomotor Domains","text":"<ul> <li>For courses where emotional engagement (Affective Domain) or hands-on skills (Psychomotor Domain) are important, Bloom's Taxonomy can also be used to create a second set of dependencies showing how students develop attitudes or skills over time. For example, psychomotor skills may start with simple tasks (guided response) and advance to complex projects (adaptation, origination).</li> </ul>"},{"location":"chapters/02-blooms-taxonomy/#example-of-a-concept-dependency-graph-using-blooms-taxonomy","title":"Example of a Concept Dependency Graph Using Bloom's Taxonomy","text":"<ol> <li>Remember: Identify basic circuit elements (resistor, capacitor).<ul> <li>Dependencies: None</li> </ul> </li> <li>Understand: Explain how Ohm's Law works in a simple circuit.<ul> <li>Dependency: Remember basic elements</li> </ul> </li> <li>Apply: Calculate voltage, current, and resistance in a circuit.<ul> <li>Dependency: Understand Ohm's Law</li> </ul> </li> <li>Analyze: Compare different circuit designs and their behaviors.<ul> <li>Dependency: Apply Ohm's Law in calculations</li> </ul> </li> <li>Evaluate: Assess the efficiency of different circuits.<ul> <li>Dependency: Analyze circuit designs</li> </ul> </li> <li>Create: Design a complete circuit to meet specific requirements.<ul> <li>Dependency: Evaluate circuit options and efficiency</li> </ul> </li> </ol>"},{"location":"chapters/02-blooms-taxonomy/#benefits-of-using-blooms-taxonomy-in-concept-dependency-graphs","title":"Benefits of Using Bloom's Taxonomy in Concept Dependency Graphs","text":"<ul> <li>Clear Learning Path: It shows a clear path from basic to advanced learning, ensuring students build their understanding progressively.</li> <li>Targeted Instruction: Instructors can design lessons and activities to align with specific cognitive levels, making it easier to address gaps.</li> <li>Tailored Assessment: The taxonomy helps structure assessments to evaluate students at different cognitive levels, from simple recall to complex synthesis.</li> <li>Holistic Learning: Combining all three domains (cognitive, affective, and psychomotor) ensures a balanced learning experience.</li> </ul> <p>By using Bloom's Taxonomy in concept dependency graphs, you can effectively map out not only the sequence of topics but also the increasing complexity and depth of student learning throughout the course.</p>"},{"location":"chapters/02-blooms-taxonomy/#references","title":"References","text":""},{"location":"chapters/02-blooms-taxonomy/#image-reference","title":"Image Reference","text":"<p>Image Reference CITT University of Florida</p>"},{"location":"chapters/02-concepts/","title":"Concepts","text":"<p>In this course, it is important to give the term \"concept\" a precise definition.  Borrowing from the World-Wide-Web (W3C) standard for storing knowledge (SKOS), here is the definition for the term \"concept\" they use:</p>"},{"location":"chapters/02-concepts/#definition-for-learning-graphs","title":"Definition for Learning Graphs","text":"<p>SKOS Definition of Concept: A unit of thought, an idea, or a notion, which is considered as an atomic unit of meaning within a given context.</p> <p>This is a broad definition and to make it a little more useful, we will add one additional property: let's require concepts to have a name.  We also refine \"given context\" to a specific learning context such as a course or curriculum.  Here is the full definition we can use for this course:</p> <p>Course Definition of Concept: A named unit of thought, such as an idea or notion, which is considered as an atomic unit of meaning within a given learning context.</p> <p>In general, think of opening a high-school or college textbook and looking at the index at the back of the book.  Each item in the index is typically a concept in that course.  If the authors for the book think that it is important enough, they will list it in the index.</p> <p>There are certainly concepts that don't have names.  Our neocortex stores around 82 billion neurons and LLMs have trillions of neuron-like structures in their neural networks.  Studies have shown that some LLM models can enumerate around 20 million named concepts.  But for all practical purposes, in this course all concepts have a name.  Technically, the primary name given to a concept is called a Preferred Label. If a concept has other names they are called Alternate Labels</p>"},{"location":"chapters/02-concepts/#concepts-vs-content","title":"Concepts vs. Content","text":"<p>It is important to not confused an abstract Named Concept from specific content such as a lesson plan, a wikipedia page, an instructional simulation (MicroSim) or a video.  In general, content has references to one or more concepts, but concepts are more atomic building blocks that help us arrange content.</p>"},{"location":"chapters/02-concepts/#how-many-concepts-in-a-high-school-course","title":"How Many Concepts in a High School Course?","text":"<p>The number of concepts covered in a typical high-school course can vary significantly depending on the subject, the curriculum, and the level of depth expected. However, a general estimate can be made.  In this analysis, we will use the term \"core concept\" as being a concept that is introduced within a course, has a clear name, and is used consistency across many educational systems.</p> <p>The number of core concepts introduce in a course also varies by subject area.  Here are some examples.</p> <ol> <li> <p>Mathematics: A high school algebra or geometry course might cover around 100 to 150 key concepts. These include foundational ideas such as solving equations, graphing functions, and understanding geometric proofs. Advanced courses like calculus might introduce 50 to 100 additional, more specialized concepts.</p> </li> <li> <p>Science: In a typical biology, chemistry, or physics course, students might learn around 200-300 major concepts. For example, a biology course might introduce cell structure, genetics, ecosystems, and evolution, while a chemistry course could cover atomic theory, chemical reactions, and thermodynamics. Physics might introduce concepts related to motion, energy, and electricity.</p> </li> <li> <p>Literature/Language Arts: An English literature course may cover 50 to 100 major literary concepts, such as themes, symbolism, metaphor, and narrative structure. It might also include concepts related to specific literary movements, authors, and genres.</p> </li> <li> <p>Social Studies: A history or civics course may focus on 150-200 key concepts, including historical events, political theories, government structures, and cultural movements.</p> </li> </ol> <p>Each course typically emphasizes a set of core concepts while also encouraging students to connect these ideas with broader themes or related areas of study. The number of concepts can be thought of as the core building blocks students are expected to understand and apply by the end of the course.</p> <p>These estimates are drawn from educational standards such as the Common Core and subject-specific curriculum guides from various educational boards.</p>"},{"location":"chapters/02-concepts/#counting-indexed-concepts","title":"Counting Indexed Concepts","text":"<p>The number of concepts typically listed in the index or glossary at the back of a high-school or college textbook varies depending on the subject and depth of the material. However, here are general estimates:</p> <ol> <li> <p>High-School Textbooks:</p> <ul> <li>Science (e.g., Biology, Chemistry): 200--400 key terms and concepts. For instance, a biology textbook may include concepts like \"photosynthesis,\" \"cell division,\" and \"genetic inheritance.\"</li> <li>Mathematics (e.g., Algebra, Geometry): Around 100--250 concepts, including \"quadratic equations,\" \"trigonometric functions,\" and \"coordinate geometry.\"</li> <li>Literature/Language Arts: 100--200 literary terms, including concepts such as \"alliteration,\" \"foreshadowing,\" and \"narrative structure.\"</li> <li> <p>College Textbooks:</p> </li> <li> <p>Introductory Courses (e.g., Psychology, Economics, Physics): 300--500 concepts, covering key definitions, theories, and models. For example, an introductory psychology textbook might list terms like \"cognitive dissonance,\" \"classical conditioning,\" and \"neuroplasticity.\"</p> </li> <li>Advanced Courses (e.g., Organic Chemistry, Advanced Calculus): 400--600 concepts, especially in subjects with extensive technical terminology.</li> </ul> </li> </ol> <p>In most textbooks, the index or glossary is a critical tool for students to reference important concepts, which are often highlighted in bold or italic throughout the text. The number of concepts aligns with the complexity of the course and the learning outcomes set by educational standards.</p>"},{"location":"chapters/03-concept-dependency/","title":"Concept Dependency","text":"<p>In this chapter, we will explore the core of learning graphs: how concepts are interrelated and how those relationships can be visualized in a dependency graph. You've already been introduced to Learning Concepts and Bloom's Taxonomy, so we'll focus on structuring these concepts based on their inherent dependencies. This will allow educators, learners, and AI-driven systems to generate a pathway through a body of knowledge, ensuring that foundational concepts (prerequisites) are learned before more advanced ideas are introduced.</p>"},{"location":"chapters/03-concept-dependency/#understanding-concept-dependencies","title":"Understanding Concept Dependencies","text":"<p>Concept dependencies refer to the relationships between various learning concepts, where one concept must be understood before another can be fully grasped. Just as in building a house, where you need a solid foundation before constructing the walls, in learning, certain foundational concepts need to be mastered before more advanced ones are introduced.</p> <p>A dependency graph illustrates these relationships by placing foundational concepts as prerequisites and showing the pathways that lead from basic understanding to advanced learning goals. Each node in the graph represents a learning concept, and the directed edges show the dependencies between them. This way, a learner or an educator can navigate through a structured sequence, ensuring all required knowledge is obtained progressively.</p>"},{"location":"chapters/03-concept-dependency/#foundational-concepts-prerequisites","title":"Foundational Concepts (Prerequisites)","text":"<p>Foundational concepts form the base of any learning graph. These are the ideas or skills that a learner must acquire first to build towards more complex or specialized topics. Without a firm grasp of these, learners often struggle to progress.</p> <p>Example: In a math curriculum, understanding basic algebra is a foundational concept before attempting to learn calculus. Without algebra, calculus would be incomprehensible because many of its principles are rooted in algebraic manipulation.</p>"},{"location":"chapters/03-concept-dependency/#identifying-prerequisites","title":"Identifying Prerequisites","text":"<p>A key step in constructing a concept dependency graph is identifying the foundational concepts or prerequisites for a particular learning goal. To do this, an instructor or AI system may:</p> <ul> <li>Analyze the knowledge required for a given task or topic and work backward to find the simplest concepts that must be understood.</li> <li>Use Bloom's Taxonomy to ensure that lower-level cognitive skills (e.g., knowledge, comprehension) are addressed before higher-level skills (e.g., synthesis, evaluation).</li> <li>Consult existing educational frameworks like SKOS (Simple Knowledge Organization System) to structure these relationships.</li> </ul> <p>Dependencies are not always linear. Some concepts might have multiple prerequisites, while others might lead to a variety of advanced learning goals. The goal of a dependency graph is to map out these relationships clearly.</p>"},{"location":"chapters/03-concept-dependency/#learning-goals","title":"Learning Goals","text":"<p>While foundational concepts form the base, learning goals are the milestones or outcomes that a learner strives to achieve. Learning goals typically represent the higher-order concepts within the graph. These are the end points in the learning journey, where learners apply their knowledge in real-world contexts, solve complex problems, or demonstrate mastery over a subject.</p> <p>Learning goals can be structured across multiple levels. For instance:</p> <ul> <li>Immediate goals: Mastering a concept that serves as a building block for further learning.</li> <li>Intermediate goals: Acquiring skills that allow for more sophisticated understanding.</li> <li>Ultimate goals: Achieving proficiency that allows learners to tackle real-world challenges or expert-level problems.</li> </ul> <p>In a dependency graph, these learning goals might appear toward the right side (if you imagine the graph flowing from left to right), while foundational concepts would be on the left. The edges in the graph show the learner's path through intermediate concepts, from the foundations toward their ultimate learning goals.</p>"},{"location":"chapters/03-concept-dependency/#ordering-concepts-using-a-dependency-graph","title":"Ordering Concepts Using a Dependency Graph","text":"<p>Creating an ordered structure for learning involves placing concepts in a sequence that respects the dependencies between them. The goal is to create a smooth progression where learners build on prior knowledge without facing gaps.</p> <ol> <li> <p>Define the foundational concepts: Start by identifying the most basic concepts that learners need to understand. These will be positioned at the far left of the graph.</p> </li> <li> <p>Identify intermediate concepts: Determine the concepts that rely on these foundational ideas. These will sit in the middle of the graph, acting as bridges between the base concepts and the more advanced learning goals.</p> </li> <li> <p>Set learning goals: Establish the final, most advanced concepts. These will represent the culmination of the learner's journey and often involve synthesizing knowledge from several intermediate areas.</p> </li> <li> <p>Draw dependencies: The edges connecting the nodes (concepts) in the graph represent the knowledge dependencies. They show that one concept must be learned before another. By tracing the path through these edges, you can clearly see the required learning trajectory.</p> </li> <li> <p>Consider feedback loops: Not all learning is purely linear. Some advanced concepts might lead learners to revisit foundational ideas at a deeper level. These feedback loops can be added to the graph to represent cyclical learning processes.</p> </li> </ol>"},{"location":"chapters/03-concept-dependency/#practical-example","title":"Practical Example","text":"<p>Let's imagine constructing a concept dependency graph for an introductory computer programming course:</p> <ul> <li>Foundational Concepts: Variables, basic syntax, control flow (if statements, loops).</li> <li>Intermediate Concepts: Functions, data structures (arrays, lists), error handling.</li> <li>Learning Goals: Algorithm design, problem-solving with recursion, and object-oriented programming.</li> </ul> <p>The graph would begin with basic syntax and variables as foundational concepts, then flow into control flow and functions. From functions, learners could move on to data structures, which would eventually lead them to algorithm design. By the time learners reach the learning goal of recursion, they would have mastered the prerequisite skills to understand and apply it effectively.</p>"},{"location":"chapters/03-concept-dependency/#concept-dependency-in-adaptive-learning-systems","title":"Concept Dependency in Adaptive Learning Systems","text":"<p>One of the key benefits of creating a concept dependency graph is its application in adaptive learning systems. Generative AI can use these graphs to tailor learning experiences to individual students, ensuring that they are introduced to concepts in the correct order. For instance, if a learner struggles with an intermediate concept, the system can direct them back to the foundational concept that they need to reinforce.</p>"},{"location":"chapters/03-concept-dependency/#structural-checks","title":"Structural Checks","text":"<p>When constructing a concept dependency graph, it's essential to ensure that the structure is complete, coherent, and connected. Without proper structural checks, gaps in the graph could lead to missing or disjointed learning pathways, making it difficult for learners to progress logically from one concept to the next. In this section, we will discuss three key structural checks: ensuring the presence of foundational concepts and learning goals, verifying that every concept is connected to the graph, and eliminating \"orphan nodes.\"</p>"},{"location":"chapters/03-concept-dependency/#check-1-ensure-at-least-one-foundational-concept","title":"Check 1: Ensure At Least One Foundational Concept","text":"<p>A well-formed concept dependency graph must have at least one foundational concept. These concepts serve as the entry points for learning and should be positioned at the base of the graph. Without foundational concepts, learners would have no starting point, which would undermine the structure of the learning pathway.</p> <p>Check: Review your graph to confirm that there are one or more concepts that do not depend on any other nodes. These concepts should be at the far left of the graph (in a left-to-right representation) or at the top (if using a top-down layout). They represent the starting point of the learning journey.</p>"},{"location":"chapters/03-concept-dependency/#check-2-ensure-at-least-one-learning-goal","title":"Check 2: Ensure At Least One Learning Goal","text":"<p>While foundational concepts form the base, the graph should also culminate in at least one learning goal. Learning goals are the ultimate objectives that learners are working toward, representing the most advanced concepts in the graph.</p> <p>Check: Ensure that the graph has at least one concept that represents a learning goal, positioned at the far right (or bottom) of the graph. These should be nodes that no other concepts depend on, indicating that they are the end points of the learning journey.</p>"},{"location":"chapters/03-concept-dependency/#check-3-eliminate-orphan-nodes","title":"Check 3: Eliminate \"Orphan Nodes\"","text":"<p>One of the most critical structural checks is to ensure that there are no \"orphan nodes\" in the graph. An orphan node is a concept that is isolated from the rest of the graph, with no connections (edges) linking it to other concepts. Orphan nodes disrupt the learning flow, as they represent knowledge that is either unconnected to the foundational concepts or unhelpful for achieving the learning goals.</p> <p>Check: Examine the graph to verify that every concept is connected to at least one other concept via an edge. Each node should either have a prerequisite or be a prerequisite for another concept. If any concept lacks connections, you must investigate why and either remove it from the graph or establish the appropriate connections.</p>"},{"location":"chapters/03-concept-dependency/#check-4-verify-full-coverage-of-the-learning-path","title":"Check 4. Verify Full Coverage of the Learning Path","text":"<p>A final structural check is to ensure that the graph provides a full, connected learning path from foundational concepts to learning goals. There should be a clear progression from one side of the graph to the other, where learners can start with the most basic concepts and build up toward mastery.</p> <p>Check: Trace multiple paths through the graph from the foundational concepts to the learning goals. This will help you confirm that learners can follow a continuous sequence of concepts and that no intermediate concepts are skipped. Each concept should serve as either a stepping stone to more advanced topics or as a prerequisite for building necessary knowledge.</p>"},{"location":"chapters/03-concept-dependency/#summary-of-structural-checks","title":"Summary of Structural Checks","text":"<p>Structural checks are vital for ensuring the integrity of a concept dependency graph. By verifying the presence of foundational concepts and learning goals, eliminating orphan nodes, and ensuring all concepts are connected, you can create a well-structured and cohesive learning pathway. These checks not only enhance the flow of knowledge but also ensure that learners have a clear, progressive route through the subject matter without facing gaps or isolated ideas. In both traditional and AI-driven learning environments, performing structural checks is crucial for optimizing the effectiveness of the graph.</p> <p>Add one more section called \"Generating Dependency Graphs with Large-Language-Models\". Talk about how a list of concepts can be an input, and the LLM can then be used to generate a draft of the concept dependencies using the appropriate prompt. The prompt should contain: 1. The list of Concepts 2. Instructions for adding Concept Dependencies for each concept 3. Checks for Foundational Concepts (prerequisites) 4. Checks for Learning Goals 5. Checks for duplication and avoidance of orphaned nodes Generate a sample prompt use for a large-langauge model.</p>"},{"location":"chapters/03-concept-dependency/#generating-dependency-graphs-with-large-language-models","title":"Generating Dependency Graphs with Large-Language Models","text":"<p>One of the most powerful applications of Large Language Models (LLMs) in education is their ability to assist in the generation of concept dependency graphs. By inputting a list of learning concepts, an LLM can draft the relationships between them, identifying which concepts are foundational, intermediate, and learning goals. This enables instructors, curriculum designers, and AI systems to quickly scaffold a structured learning pathway.</p> <p>Using LLMs, you can generate these dependencies through a carefully constructed prompt, which not only lists the concepts but also provides specific instructions for the LLM to organize them into a coherent dependency graph. In this section, we'll explore how to craft such a prompt and leverage LLMs to check for structural integrity, such as ensuring there are no orphaned nodes, that all prerequisites are included, and that learning goals are clearly defined.</p>"},{"location":"chapters/03-concept-dependency/#creating-the-prompt","title":"Creating the Prompt","text":"<p>To generate a concept dependency graph using an LLM, the following elements should be included in the prompt:</p> <ol> <li>List of Concepts: Begin by providing the LLM with a list of concepts that need to be organized.</li> <li>Instructions for Adding Concept Dependencies: Guide the LLM to identify which concepts are prerequisites and which are advanced learning goals.</li> <li>Check for Foundational Concepts: Ensure that the LLM starts with the most basic ideas, identifying concepts that do not depend on others.</li> <li>Check for Learning Goals: Ask the LLM to identify the ultimate learning objectives that serve as end points in the learning pathway.</li> <li>Avoidance of Orphan Nodes: Instruct the LLM to verify that all concepts are connected, ensuring that there are no isolated, unlinked concepts in the graph.</li> <li>Check for Duplications: Make sure that the LLM doesn't introduce duplicate concepts or redundant dependencies.</li> </ol>"},{"location":"chapters/03-concept-dependency/#sample-prompt-for-llm","title":"Sample Prompt for LLM","text":"<p>Below is an example prompt that could be used to generate a concept dependency graph using an LLM:</p> <p>Prompt:</p> <pre><code>You are given the following list of concepts. Your task is to\ngenerate a concept dependency graph where each concept is\nplaced according to its dependencies. Each concept should\neither depend on one or more prerequisites or be a prerequisite\nfor others. You must check for the following:\n\n-   Identify at least one foundational concept that serves\nas a starting point. These concepts should not depend on others.\n-   Identify at least one learning goal that serves as the end point of the graph. These concepts should not have any dependencies and represent the most advanced topics.\n-   Ensure there are no \"orphan nodes\" (concepts without any connections).\n-   Avoid duplicating concepts or introducing redundant relationships.\n\n**List of Concepts:**\n\n1.  Basic Algebra\n2.  Calculus\n3.  Trigonometry\n4.  Graph Theory\n5.  Differential Equations\n6.  Linear Algebra\n7.  Functions and Relations\n8.  Derivatives\n9.  Integrals\n\n**Instructions:**\n\n1.  Begin by identifying the foundational concepts (prerequisites) that serve as the base of the graph.\n2.  For each concept, specify its prerequisites. For example, calculus depends on understanding basic algebra, functions and relations, and trigonometry.\n3.  Identify the learning goals, which should appear as advanced concepts with no further dependencies. In this case, consider topics like graph theory or differential equations.\n4.  Ensure that each concept is connected, forming a continuous learning path from foundational concepts to learning goals.\n5.  Verify that no concepts are duplicated or incorrectly connected.\n</code></pre>"},{"location":"chapters/03-concept-dependency/#how-llms-use-this-prompt","title":"How LLMs Use This Prompt","text":"<p>When provided with a prompt like the one above, an LLM can analyze the list of concepts, draw logical connections, and generate a draft of the concept dependency graph. The model will:</p> <ul> <li>Place basic algebra as a foundational concept because it is a prerequisite for most other topics.</li> <li>Connect calculus, derivatives, and integrals with algebra, functions, and trigonometry.</li> <li>Assign learning goals such as differential equations and graph theory as advanced concepts that rely on prior knowledge from calculus and linear algebra.</li> <li>Ensure that every concept has at least one connection to other nodes, eliminating orphan nodes.</li> <li>Perform structural checks to avoid redundancy or disconnection in the graph.</li> </ul> <p>This process significantly reduces the manual effort required to map out dependencies, allowing educators and AI systems to focus on refining and enhancing the learning experience rather than spending time identifying prerequisites.</p>"},{"location":"chapters/03-concept-dependency/#sample-response","title":"Sample Response","text":"<p>To generate a concept dependency graph based on the given list of concepts, we will first identify foundational concepts, establish the dependencies, and then determine learning goals. Here's how we can organize the dependencies step-by-step:</p>"},{"location":"chapters/03-concept-dependency/#foundational-concepts-prerequisites_1","title":"Foundational Concepts (Prerequisites):","text":"<ol> <li>Basic Algebra -- This is a foundational concept that doesn't depend on other concepts and serves as the base for many other mathematical topics.</li> <li>Functions and Relations -- Another fundamental concept that underpins understanding more advanced topics in mathematics.</li> </ol>"},{"location":"chapters/03-concept-dependency/#intermediate-concepts","title":"Intermediate Concepts:","text":"<ol> <li>Trigonometry -- Depends on both Basic Algebra and Functions and Relations for its mathematical foundations.</li> <li>Linear Algebra -- Requires Basic Algebra and Functions and Relations to understand matrices, vectors, and their operations.</li> <li>Derivatives -- Depends on Basic Algebra, Functions and Relations, and Trigonometry. Derivatives are a key part of calculus and rely on these foundational topics.</li> <li>Integrals -- Depends on Derivatives, Basic Algebra, and Trigonometry. Mastering integrals requires a strong understanding of the prerequisite topics that lead to calculus.</li> </ol>"},{"location":"chapters/03-concept-dependency/#advanced-concepts-learning-goals","title":"Advanced Concepts (Learning Goals):","text":"<ol> <li>Calculus -- This advanced concept depends on Basic Algebra, Trigonometry, and Functions and Relations. It leads to understanding derivatives and integrals.</li> <li>Differential Equations -- This is a learning goal that builds on Calculus and Linear Algebra. It requires a thorough understanding of these concepts but does not introduce new prerequisites.</li> <li>Graph Theory -- This advanced topic depends primarily on Linear Algebra but stands alone in many respects. It serves as an end point in certain mathematical learning paths.</li> </ol>"},{"location":"chapters/03-concept-dependency/#graph-overview","title":"Graph Overview:","text":"<ol> <li>Basic Algebra \u2192 Functions and Relations \u2192 Trigonometry</li> <li>Basic Algebra \u2192 Linear Algebra</li> <li>Functions and Relations \u2192 Derivatives \u2192 Integrals</li> <li>Trigonometry \u2192 Derivatives</li> <li>Derivatives \u2192 Calculus \u2192 Differential Equations</li> <li>Linear Algebra \u2192 Graph Theory</li> </ol>"},{"location":"chapters/03-concept-dependency/#continuous-path","title":"Continuous Path:","text":"<ul> <li>The graph starts with Basic Algebra and Functions and Relations, which flow into Trigonometry and Linear Algebra. From there, Derivatives and Integrals lead into Calculus, which then extends into more specialized topics like Differential Equations and Graph Theory.</li> </ul>"},{"location":"chapters/03-concept-dependency/#no-orphan-nodes","title":"No Orphan Nodes:","text":"<ul> <li>All concepts are connected, with clear dependencies between them. There are no orphan nodes, ensuring that each concept either builds on or leads to another concept.</li> </ul>"},{"location":"chapters/03-concept-dependency/#no-redundancies","title":"No Redundancies:","text":"<ul> <li>Each concept is introduced only once, and the dependencies are logically structured without duplication or redundant relationships.</li> </ul> <p>This approach creates a well-ordered and connected concept dependency graph, ensuring that learners progress logically through the material from foundational concepts to advanced learning goals.</p>"},{"location":"chapters/03-concept-dependency/#conclusion","title":"Conclusion","text":"<p>Using LLMs to generate concept dependency graphs streamlines the design of learning pathways. With a well-constructed prompt, LLMs can map foundational concepts, intermediate ideas, and learning goals, ensuring that all concepts are connected in a coherent structure. This method not only accelerates the creation of dependency graphs but also ensures that the structure is complete, eliminating orphaned nodes and redundancies.</p>"},{"location":"chapters/03-concept-dependency/#data-formats-for-concept-dependency-lists","title":"Data Formats for Concept Dependency Lists","text":"<p>In this course, we will use two difference file formats for storing our learning graphs:</p> <ol> <li>CSV Format - this format is simple and easy for beginners to create with a spreadsheet or text editor.  It is also easy for generative AI tools to generate. Just be aware that you must use quotes to surround names that contain commas.</li> <li>JSON Format - this format is easy for tools like vis.js to read and view. There are also tools to validate this format for correctness.</li> </ol> <p>We also proved Python tools to convert between these formats. See the \"src/csv-to-json\" area of this repo for examples of these tools.</p>"},{"location":"chapters/03-concept-dependency/#csv-format","title":"CSV Format","text":"<pre><code>ConceptID,ConceptName,DependentConceptIDs\n1,Basic Algebra,2|3|4|5\n2,Functions and Relations,3|5\n3,Trigonometry,5\n4,Linear Algebra,7|9\n5,Derivatives,6\n6,Integrals,\n7,Calculus,8\n8,Differential Equations,\n9,Graph Theory,\n</code></pre> <p>Note that the last two foundational concepts do not have dependencies.</p>"},{"location":"chapters/03-concept-dependency/#json-format","title":"JSON Format","text":"<pre><code>{\"nodes\": [\n    {\"id\": 1, \"label\": \"Basic Algebra\"},\n    {\"id\": 2, \"label\": \"Functions and Relations\"},\n    {\"id\": 3, \"label\": \"Trigonometry\"},\n    {\"id\": 4, \"label\": \"Linear Algebra\"},\n    {\"id\": 5, \"label\": \"Derivatives\"},\n    {\"id\": 6, \"label\": \"Integrals\"},\n    {\"id\": 7, \"label\": \"Calculus\"},\n    {\"id\": 8, \"label\": \"Differential Equations\"},\n    {\"id\": 9, \"label\": \"Graph Theory\"}],\n\"edges\": [\n    {\"from\": 1, \"to\": 2}, \n    {\"from\": 1, \"to\": 3}, \n    {\"from\": 1, \"to\": 4}, \n    {\"from\": 2, \"to\": 3}, \n    {\"from\": 2, \"to\": 5}, \n    {\"from\": 3, \"to\": 5}, \n    {\"from\": 4, \"to\": 7}, \n    {\"from\": 4, \"to\": 9}, \n    {\"from\": 5, \"to\": 6}, \n    {\"from\": 7, \"to\": 8}\n]}\n</code></pre>"},{"location":"chapters/03-concept-dependency/#conclusion_1","title":"Conclusion","text":"<p>Concept dependency is the backbone of any structured learning experience. By understanding the relationships between foundational concepts and learning goals, educators can create clearer, more effective pathways for learners. These paths can be visualized and utilized through concept dependency graphs, which not only provide a roadmap for the learner but also help AI systems tailor education to meet individual needs.</p> <p>A well-constructed concept dependency graph ensures that learning is progressive, avoids gaps, and builds toward meaningful goals. Whether you're developing a curriculum or designing an adaptive learning system, understanding and applying concept dependency will ensure that learners can build a solid foundation for advanced understanding and success.</p>"},{"location":"chapters/04-concept-taxonomies/","title":"Concept Taxonomies and Ontologies","text":"<p>In this chapter, we will explore how concepts can be grouped and classified using taxonomies and ontologies. By organizing concepts into meaningful categories, curriculum designers can create richer learning experiences. Taxonomies and ontologies help structure learning content, making it easier to intermix abstract theories with concrete examples, reinforcing learning through diverse types of engagement.</p>"},{"location":"chapters/04-concept-taxonomies/#concept-taxonomies","title":"Concept Taxonomies","text":"<p>A taxonomy is a structured classification of concepts into categories or types, typically in a hierarchical arrangement. In education, concept taxonomies help group ideas based on shared characteristics, making it easier to design a curriculum that balances foundational knowledge with higher-order thinking.</p>"},{"location":"chapters/04-concept-taxonomies/#classifying-concepts-in-a-taxonomy","title":"Classifying Concepts in a Taxonomy","text":"<p>In the context of a learning graph, concepts can be classified in a variety of ways. Below are some common categories that can be used to classify educational content:</p> <ol> <li> <p>Basic Terminology: Concepts that define the core vocabulary of a subject. These serve as building blocks for further understanding. For example, in a computer science course, terms like \"algorithm,\" \"data structure,\" or \"function\" would belong here.</p> </li> <li> <p>Mathematical Concepts: These are abstract ideas that rely on logic and mathematics. They are foundational for many fields, such as physics, economics, or engineering. Concepts like \"linear algebra,\" \"calculus,\" and \"probability theory\" would be part of this category.</p> </li> <li> <p>Recurring Patterns: These are general principles or patterns that appear across different contexts. Examples include \"design patterns\" in software development or \"behavioral patterns\" in psychology.</p> </li> <li> <p>Anti-patterns: These are practices or ideas that may seem beneficial but should be avoided. For example, \"premature optimization\" in coding or \"confirmation bias\" in decision-making.</p> </li> <li> <p>Common Misunderstandings: Concepts that are often misunderstood or misapplied. These can serve as important checkpoints in a learning journey, ensuring that students overcome pitfalls.</p> </li> <li> <p>Illustrations: These are visual representations of concepts, such as diagrams, charts, and graphs. For example, in physics, an illustration of Newton's laws using a force diagram helps learners visualize abstract ideas.</p> </li> <li> <p>Useful Metaphors: Metaphors can simplify complex topics by comparing them to something familiar. For instance, describing \"RAM\" in computing as a \"workspace\" where immediate tasks are performed.</p> </li> <li> <p>Stories or Case Studies: Real-world stories or case studies that show how concepts are applied in practice. These are crucial for reinforcing theoretical knowledge with practical examples.</p> </li> <li> <p>Application of Concepts to Real-World Problems: This involves showing learners how abstract concepts translate into real-world solutions. For instance, how linear algebra is used in 3D modeling or how probability is applied in risk assessment.</p> </li> <li> <p>Warnings about Appropriate Use: These are concepts that warn learners about the limitations or potential misuse of an idea. For example, cautioning students about overfitting in machine learning models.</p> </li> <li> <p>Hands-on Activities: These include experiments, labs, or other interactive activities that allow learners to engage directly with the material. Building a simple circuit or conducting a chemistry experiment are examples.</p> </li> <li> <p>Simulations: Simulations provide a dynamic environment where learners can experiment with different scenarios and see how concepts behave in real time. For example, using software to simulate population growth or stock market fluctuations.</p> </li> </ol>"},{"location":"chapters/04-concept-taxonomies/#the-role-of-taxonomies-in-course-design","title":"The Role of Taxonomies in Course Design","text":"<p>By organizing concepts into a taxonomy, curriculum authors can carefully design a balanced course that introduces learners to a mix of theoretical and practical concepts. The taxonomy allows instructors to move between different levels of abstraction, ensuring that learners don't get bogged down in too much theory without seeing its real-world application.</p> <p>Example: In a course on electrical engineering, the taxonomy might look like this:</p> <ul> <li>Basic Terminology: Voltage, Current, Resistance</li> <li>Mathematical Concepts: Ohm's Law, Kirchhoff's Laws</li> <li>Hands-on Activities: Building a simple circuit using resistors and an LED</li> <li>Illustrations: Circuit diagrams, flow of current representation</li> <li>Simulations: Using a circuit simulator to test different configurations</li> <li>Warnings: The dangers of working with high voltage or improper grounding</li> </ul> <p>A well-designed course would cycle between these classifications, providing learners with varied opportunities to engage with the material.</p>"},{"location":"chapters/04-concept-taxonomies/#concept-ontologies","title":"Concept Ontologies","text":"<p>While taxonomies organize concepts into hierarchical groups, ontologies take this a step further by explicitly defining the relationships between concepts. In other words, an ontology not only classifies concepts but also explains how they are related to one another. In the context of learning, this could mean defining how one concept depends on another, how concepts are grouped, and how they fit into a broader body of knowledge.</p>"},{"location":"chapters/04-concept-taxonomies/#ontologies-in-learning-graphs","title":"Ontologies in Learning Graphs","text":"<p>Ontologies can help clarify the dependencies and relationships between learning concepts, ensuring that no important connections are overlooked. For example:</p> <ul> <li>Concept A depends on Concept B: In a physics course, Newton's Second Law (Concept A) depends on an understanding of force and mass (Concept B).</li> <li>Concept C is a prerequisite for Concept D: In calculus, understanding derivatives (Concept C) is necessary before tackling integrals (Concept D).</li> </ul> <p>Ontologies allow for more complex relationships beyond simple prerequisites. They can capture nuanced relationships such as:</p> <ul> <li>Concept E complements Concept F: In literature, understanding symbolism (Concept E) complements the study of metaphor (Concept F).</li> <li>Concept G contrasts with Concept H: In a philosophy course, the idea of free will (Concept G) contrasts with determinism (Concept H).</li> </ul>"},{"location":"chapters/04-concept-taxonomies/#practical-applications-of-taxonomies-and-ontologies","title":"Practical Applications of Taxonomies and Ontologies","text":"<p>By integrating taxonomies and ontologies, curriculum designers can develop richer learning experiences. Here's how these frameworks enhance learning:</p> <ol> <li> <p>Customization and Differentiation: By identifying various types of concepts, instructors can tailor learning experiences to different learners' needs. Some students may excel with hands-on activities, while others may grasp abstract concepts more easily. A taxonomy of concept types helps create a varied learning experience.</p> </li> <li> <p>Interweaving Theory and Practice: Using a taxonomy to intermix abstract concepts with case studies, metaphors, or hands-on activities can reinforce learning. A lesson on programming algorithms might alternate between introducing the theory (taxonomy: mathematical concept) and showing real-world applications (taxonomy: application of concepts to real-world problems).</p> </li> <li> <p>Adaptive Learning: Ontologies, with their detailed relationships between concepts, are particularly useful for adaptive learning systems. As learners master foundational concepts, the system can automatically guide them to more advanced topics, ensuring that they progress along a logical path.</p> </li> <li> <p>Reducing Misunderstandings: By including \"common misunderstandings\" and \"warnings\" in a taxonomy, educators can proactively address areas where learners typically struggle, minimizing confusion.</p> </li> </ol>"},{"location":"chapters/04-concept-taxonomies/#concept-taxonomy-legends","title":"Concept Taxonomy Legends","text":""},{"location":"chapters/04-concept-taxonomies/#using-a-groupsjson-file","title":"Using a groups.json File","text":"<p>In our labs, we will often generate a small taxonomy of around 10 classifiers. We then want to use these classifiers to display concepts is a way that allow our authors to see patterns in complex learning graphs.  We have adopted a standard format for storing taxonomies called the groups.json format.</p> <p>For each category or group, we can store the following properties:</p> <ol> <li>The background and border color of each unselected node</li> <li>The background and border color of each node when you hover your mouse over the node</li> <li>The background and border color of each node when you select the node</li> <li>The shape and size of the node.  For example we use \"box\" for foundation nodes and star for course goals</li> </ol> <p>Here is an example of this format:</p> <pre><code>{\n    \"Foundation\": {\n        \"color\": {\n            \"background\": \"DarkSalmon\",\n            \"border\": \"FireBrick\",\n            \"highlight\": {\n                \"background\": \"LightSalmon\",\n                \"border\": \"DarkRed\"\n            },\n            \"hover\": {\n                \"background\": \"Salmon\",\n                \"border\": \"DarkRed\"\n            }\n        },\n        \"shape\": \"dot\",\n        \"size\": 20\n    },\n    \"Level 2\": {\n        \"color\": {\n            \"background\": \"DarkOrange\",\n            \"border\": \"OrangeRed\",\n            \"highlight\": {\n                \"background\": \"orange\",\n                \"border\": \"Tomato\"\n            },\n            \"hover\": {\n                \"background\": \"LightSalmon\",\n                \"border\": \"Coral\"\n            }\n        },\n        \"shape\": \"dot\",\n        \"size\": 20\n    },\n    \"Goal\": {\n        \"color\": {\n            \"background\": \"plum\",\n            \"border\": \"purple\",\n            \"highlight\": {\n                \"background\": \"violet\",\n                \"border\": \"mediumorchid\"\n            },\n            \"hover\": {\n                \"background\": \"LightSteelBlue\",\n                \"border\": \"SteelBlue\"\n            }\n        },\n        \"shape\": \"dot\",\n        \"size\": 20\n    }\n}\n</code></pre>"},{"location":"chapters/04-concept-taxonomies/#conclusion","title":"Conclusion","text":"<p>Classifying concepts using taxonomies and ontologies provides a structured framework that enhances the design of learning experiences. Taxonomies offer a way to group concepts into manageable categories, ensuring that courses balance abstract theory with concrete examples. Ontologies, on the other hand, define relationships between concepts, ensuring that dependencies and connections are clearly mapped.</p> <p>Together, these tools allow curriculum authors to design courses that are not only logically structured but also rich in variety and engagement. By integrating both frameworks into learning graphs, educators can create more personalized and effective learning paths, ensuring that students have the opportunity to master concepts both in theory and in practice.</p>"},{"location":"chapters/05-displaying-graphs/","title":"Displaying Learning Graphs","text":"<p>This chapter covers the details of how we display learning graphs. We attempt to keep the details of specific libraries out of this chapter and focus on the usability aspects of viewing and editing learning graphs.</p>"},{"location":"chapters/05-displaying-graphs/#terminology","title":"Terminology","text":""},{"location":"chapters/05-displaying-graphs/#concept-graphs","title":"Concept Graphs","text":"<p>A network graph data structure that uses nodes to represent concepts and edges to show the relationship between concepts.</p> <ul> <li>See also: SKOS</li> </ul>"},{"location":"chapters/05-displaying-graphs/#content-graphs","title":"Content Graphs","text":""},{"location":"chapters/05-displaying-graphs/#journey-maps","title":"Journey Maps","text":""},{"location":"chapters/05-displaying-graphs/#hybrid-graphs","title":"Hybrid Graphs","text":""},{"location":"chapters/05-displaying-graphs/#laying-out-dependency-graphs","title":"Laying out Dependency Graphs","text":""},{"location":"chapters/05-displaying-graphs/#nodes-arrow-and-labels","title":"Nodes, Arrow and Labels","text":""},{"location":"chapters/05-displaying-graphs/#force-directed-graphs","title":"Force Directed Graphs","text":""},{"location":"chapters/05-displaying-graphs/#adjusting-distances","title":"Adjusting Distances","text":""},{"location":"chapters/05-displaying-graphs/#left-to-right-and-top-down-hierarchies","title":"Left to Right and Top Down Hierarchies","text":""},{"location":"chapters/05-displaying-graphs/#pinning-foundational-concepts-and-goals","title":"Pinning Foundational Concepts and Goals","text":""},{"location":"chapters/05-displaying-graphs/#using-colors-and-shapes","title":"Using Colors and Shapes","text":""},{"location":"chapters/05-displaying-graphs/#using-size-and-borders","title":"Using Size and Borders","text":""},{"location":"chapters/05-displaying-graphs/#placing-labels-and-using-abbreviations","title":"Placing Labels and Using Abbreviations","text":""},{"location":"chapters/05-displaying-graphs/#abstraction-and-clustering","title":"Abstraction and Clustering","text":""},{"location":"chapters/05-displaying-graphs/#leveraging-taxonomies-and-ontologies","title":"Leveraging Taxonomies and Ontologies","text":""},{"location":"chapters/05-displaying-graphs/#adding-taxonomy-legends","title":"Adding Taxonomy Legends","text":""},{"location":"chapters/15-dependency-analysis/","title":"Dependency Analysis","text":"<p>In this chapter we will look at algorithms that help find all the dependencies of a given concept within a course learning graph.</p> <p>This is not just finding all the direct dependencies of a concept. It is also about finding the dependencies of the dependencies etc. The number of levels we search is called the number of \"hops\" in the dependency graph.</p>"},{"location":"chapters/17-lms-integration/","title":"Integrating with LMSs","text":""},{"location":"prompts/","title":"Prompts to Create Learning Graphs","text":""},{"location":"prompts/#concept-enumeration","title":"Concept Enumeration","text":""},{"location":"prompts/01-course-description/","title":"Course Description Prompts","text":""},{"location":"prompts/02-concept-enumeration/","title":"Concept Enumeration Prompts","text":""},{"location":"prompts/02-concept-enumeration/#sample-prompt","title":"Sample Prompt","text":"<p>Below is a course description of a course on SUBJECT I am teaching at a local HIGH SCHOOL, COLLEGE or University. Please generate a list of the 150 core concepts that need to be covered in this course and the order in which they should be taught.</p> <p>Return numbered list of these core concepts using a single line per concept.  For each concept, just return a short concept name and use acronyms or abbreviations when appropriate.  They will be used as labels in a graph network. Make sure that the concepts are distinct not duplicated in the list.</p> <p>Start with the most basic foundational concepts and then proceed to the most complex concepts.</p>"},{"location":"prompts/02-concept-enumeration/#chatgpt-response","title":"ChatGPT Response","text":""},{"location":"prompts/03-concept-dependencies/","title":"Concept Dependencies","text":""},{"location":"prompts/03-concept-dependencies/#sample-prompt","title":"Sample Prompt","text":""},{"location":"prompts/04-taxonomies/","title":"Concept Taxonomies","text":""},{"location":"prompts/04-taxonomies/#concept-taxonomy-prompts","title":"Concept Taxonomy Prompts","text":""},{"location":"prompts/04-taxonomies/#automatically-creating-a-taxonomy-for-concepts-using-large-language-models","title":"Automatically Creating a Taxonomy for Concepts Using Large Language Models","text":"<p>One of the exciting applications of Large Language Models (LLMs) in educational technology is their ability to automatically generate taxonomies from a list of concepts. By providing a set of concepts as input, an LLM can suggest logical groupings based on the nature of the concepts, their uses, and their relationships. This automatic generation of a taxonomy saves time for curriculum designers and can reveal categories that may not have been initially obvious.</p>"},{"location":"prompts/04-taxonomies/#creating-a-taxonomy-with-llms","title":"Creating a Taxonomy with LLMs","text":"<p>To generate a taxonomy using an LLM, you can craft a prompt that provides clear instructions on how to organize concepts into distinct categories. Below is a sample prompt structure for generating a taxonomy:</p>"},{"location":"prompts/04-taxonomies/#sample-taxonomy-prompt","title":"Sample Taxonomy Prompt","text":"<p>You are given the following list of concepts. Your task is to organize these concepts into a taxonomy by grouping them into appropriate categories. Each category should include concepts that share similar characteristics, functions, or applications. Suggest 7-10 categories for the taxonomy and assign each concept to one or more categories. Ensure that the categories cover a range of concept types, including abstract ideas, practical applications, common misunderstandings, and real-world examples. Avoid redundancy and ensure that each category is distinct.</p> <p>List of Concepts:</p> <ol> <li>Basic Algebra</li> <li>Trigonometry</li> <li>Derivatives</li> <li>Calculus</li> <li>Linear Algebra</li> <li>Graph Theory</li> <li>Differential Equations</li> <li>Integrals</li> <li>Functions and Relations</li> <li>Common Misunderstandings in Algebra</li> </ol> <p>Instructions:</p> <ol> <li>Identify 7-10 categories to classify these concepts.</li> <li>Group concepts into appropriate categories based on their characteristics.</li> <li>Include categories such as basic terminology, abstract concepts, hands-on activities, common misunderstandings, and applications in real-world problems.</li> <li>Ensure each category is distinct and that no concept is placed in more than one category unless appropriate.</li> <li>Suggest ways to differentiate these categories visually using color and shape in a learning graph.</li> </ol>"},{"location":"prompts/04-taxonomies/#sample-output-from-an-llm","title":"Sample Output from an LLM","text":"<p>Given this prompt, an LLM could generate a taxonomy like the following:</p> <p>Sample Generated Taxonomy</p> <ol> <li> <p>Basic Terminology:</p> <ul> <li>Basic Algebra</li> <li>Functions and Relations</li> </ul> </li> <li> <p>Mathematical Concepts:</p> <ul> <li>Trigonometry</li> <li>Calculus</li> <li>Linear Algebra</li> </ul> </li> <li> <p>Abstract Theories:</p> </li> <li> <p>Derivatives</p> </li> <li>Integrals</li> <li> <p>Differential Equations</p> </li> <li> <p>Graphical Models:</p> </li> <li> <p>Graph Theory</p> </li> <li> <p>Common Misunderstandings:</p> </li> <li> <p>Common Misunderstandings in Algebra</p> </li> <li> <p>Real-World Applications:</p> <ul> <li>Applications of Calculus to Real-World Problems</li> <li>Applications of Graph Theory in Networking</li> </ul> </li> <li> <p>Patterns and Recurring Themes:</p> <ul> <li>Functions and Relations</li> <li>Recurring patterns in Differential Equations</li> </ul> </li> </ol>"},{"location":"prompts/04-taxonomies/#differentiating-categories-visually","title":"Differentiating Categories Visually","text":"<p>Once the LLM provides a taxonomy, the next step is to visualize these groupings in a learning graph. In a visual representation, color and shape can be powerful tools to differentiate concept types and enhance understanding:</p> <ol> <li> <p>Colors: Each category can be assigned a unique color to make the relationships between concepts immediately visible. For example:</p> </li> <li> <p>Basic Terminology could be light blue to signify foundational knowledge.</p> </li> <li>Mathematical Concepts could be green to denote abstract, logical reasoning.</li> <li>Graphical Models might be red to emphasize their visual nature.</li> <li> <p>Common Misunderstandings could be orange to highlight potential pitfalls.</p> <p>Colors allow learners to quickly identify the type of concept they are engaging with and follow a consistent thread through the learning graph.</p> </li> <li> <p>Shapes: Shapes can further distinguish different types of concepts:</p> </li> <li> <p>Circles for core concepts like terminology and mathematical foundations.</p> </li> <li>Squares for practical applications or hands-on activities.</li> <li>Triangles for common misunderstandings or warnings, drawing attention to critical areas of focus.</li> <li> <p>Hexagons for recurring patterns or themes, showing how these concepts appear in multiple contexts.</p> <p>By combining both color and shape, learners can visually parse complex information at a glance, making it easier to understand how different types of knowledge interrelate.</p> </li> </ol>"},{"location":"prompts/04-taxonomies/#example-visualization-of-taxonomy-in-a-learning-graph","title":"Example: Visualization of Taxonomy in a Learning Graph","text":"<p>Imagine a learning graph where the foundational concepts (basic terminology) are represented as blue circles at the base of the graph, with arrows leading toward more advanced topics. As you progress, mathematical concepts are shown in green circles, while real-world applications are depicted in green squares. Common misunderstandings appear as orange triangles, highlighting areas where extra attention is needed. Recurring patterns are represented as hexagons, showing connections across different branches of the graph.</p> <p>This visual distinction not only helps learners identify the nature of each concept but also provides a clearer picture of how different categories of knowledge interact with each other.</p>"},{"location":"prompts/04-taxonomies/#benefits-of-using-llm-generated-taxonomies","title":"Benefits of Using LLM-Generated Taxonomies","text":"<ol> <li> <p>Time Efficiency: LLMs can quickly analyze a set of concepts and generate a well-organized taxonomy, significantly reducing the manual effort involved.</p> </li> <li> <p>Uncovering Hidden Relationships: By suggesting categories that may not be immediately obvious, LLMs can help uncover new ways of thinking about how concepts are related. For example, a category of \"common misunderstandings\" might be overlooked by an instructor but could be essential for preventing knowledge gaps.</p> </li> <li> <p>Consistent Course Design: By providing a clear taxonomy, LLMs can ensure that concepts are consistently categorized across a curriculum. This consistency helps in maintaining a structured learning experience where students can track their progress through different categories of knowledge.</p> </li> <li> <p>Enhanced Visual Learning: Using color and shape to represent categories makes learning graphs more intuitive and engaging, helping students to visualize the relationships between different types of knowledge.</p> </li> </ol>"},{"location":"prompts/04-taxonomies/#displaying-taxonomy-legends","title":"Displaying Taxonomy Legends","text":"<p>In order for viewers to view large concept graphs, it is handy to have a legend appear</p>"},{"location":"prompts/04-taxonomies/#tools-to-enrich","title":"Tools to Enrich","text":""},{"location":"prompts/04-taxonomies/#conclusion","title":"Conclusion","text":"<p>Leveraging LLMs to generate concept taxonomies is a powerful tool for organizing educational content. By classifying concepts into distinct categories such as basic terminology, abstract theories, practical applications, and common misunderstandings, educators can design more structured and engaging learning experiences. Visualizing these taxonomies using color and shape further enhances comprehension, allowing learners to easily grasp the types and relationships of concepts in a learning graph.</p> <p>This combination of automated taxonomy generation and visually distinct representations can help curriculum designers ensure that learners move through both abstract and concrete concepts fluidly, reinforcing their understanding through varied, meaningful interactions with the material.</p> <p>4o</p> <p>window.__oai_logHTML?window.__oai_logHTML():window.__oai_SSR_HTML=window.__oai_SSR_HTML||Date.now();requestAnimationFrame((function(){window.__oai_logTTI?window.__oai_logTTI():window.__oai_SSR_TTI=window.__oai_SSR_TTI||Date.now()}))</p>"},{"location":"vis/","title":"Vis Tutorials","text":"<p>This section provides guidelines for using the vis.js JavaScript library for displaying and editing learning graphs.</p>"},{"location":"vis/#why-visjs-for-learning-graph-networks","title":"Why vis.js for Learning Graph Networks","text":"<p>Although there are many JavaScript libraries that display graph networks, vis.js has a good combination of default features, sample code and an active developer community that makes it a good fit for learning graph networks.</p>"},{"location":"vis/#overview-of-steps","title":"Overview of Steps","text":""},{"location":"vis/#learning-graph-file-setup-steps","title":"Learning Graph File Setup Steps","text":"<ol> <li>Use generative AI to generate a CSV file of a learning graph.<ol> <li>Create a clear course description with prerequisites and goals using [Bloom's Taxonomy]</li> <li>Enumerate Concepts</li> <li>Find Concept dependencies</li> <li>Generate a taxonomy of concepts and place in groups.json</li> <li>Add a classifier to each Concept</li> <li>Validate the learning graph network</li> </ol> </li> <li>Convert this learning graph to JSON format.</li> <li>Use an enricher to add group=\"1\" to all foundational concepts and group=\"12\" to goals</li> </ol>"},{"location":"vis/#learning-graph-visualization","title":"Learning Graph Visualization","text":"<ol> <li>Load graph data from a JSON file and the legend from groups.json</li> <li>Log any problems such as missing foundation, goals or orphan nodes and set NODE_COUNT</li> <li>Count the number of nodes and estimate the graph X-dimension CANVAS-WIDTH</li> <li>Run the enrich_nodes() function which will:<ol> <li>Add a x=-CANVAS_WIDTH/2 to foundation nodes and set the shape to \"box\"</li> <li>Add a x=CANVAS_WIDTH/2 to goal nodes and set the shape to be \"star\"</li> </ol> </li> </ol>"},{"location":"vis/#basic-properties-of-nodes-and-edges","title":"Basic Properties of Nodes and Edges","text":""},{"location":"vis/#lab-1-default-behavior","title":"Lab 1: Default Behavior","text":"<p>Lab 1: Default Behavior</p>"},{"location":"vis/#lab-2-json","title":"Lab 2 - JSON","text":"<p>Learn the JSON format</p> <p>Lab 2: Loading Data From JSON</p>"},{"location":"vis/#lab-3-node-properties","title":"Lab 3 - Node Properties","text":"<p>Learn the Properties of a Node</p> <p>Lab 3: Node Properties</p>"},{"location":"vis/#lab-4-edge-shapes","title":"Lab 4 - Edge Shapes","text":"<p>Lab 4 - Edge Properties</p>"},{"location":"vis/#lab-5-custom-shapes","title":"Lab 5 - Custom Shapes","text":"<p>Lab 4 - Custom Shapes</p>"},{"location":"vis/#examples","title":"Examples","text":"<p>Concept Dependency Graph</p>"},{"location":"vis/#graph-editor","title":"Graph Editor","text":"<p>Learn how to create an interactive graph editor</p> <p>Graph Editor</p>"},{"location":"vis/#csv-reader","title":"CSV-Reader","text":"<p>CSV Reader</p>"},{"location":"vis/#node-enricher","title":"Node Enricher","text":"<p>Node Enricher</p>"},{"location":"vis/#adding-legends","title":"Adding Legends","text":"<p>Adding Legends</p>"},{"location":"vis/concept-dependency-graph/","title":"Concept Dependency Graph","text":"<p>SampleConcept Dependency Graph for Ohm's Law</p> <p>A Concept Dependency Graph is a specific type of graph that has the following properties.</p> <ol> <li>Each Concept is represented by a vertex and all concepts have a short name called the \"label\".</li> <li>By default circles are used to represent concepts in a graph.</li> <li>To learn a new Concept, you must understand the prerequisite concepts called the dependant concepts.</li> <li>Concepts each have a DEPENDS_ON directed link that points to what other Concepts any concept depends on.  To keep the chart ink smaller, the abbreviation \"dep\" is often used.</li> <li>A course is a collection of Concepts that must be learned in an approximate order.</li> <li>Every course has a collection of background foundational concepts that should be mastered before the student takes the course.</li> <li>Concepts that are prerequisites for the course often appear on the left edge of the concept graph at a location of x=-300.</li> <li>Advanced concepts often appear on the right at x=300</li> <li>By convention, concrete physical concepts are lower in the graph and more abstract mathematical concepts are initially located toward the top of the graph.</li> <li>When we want to focus on a concept, that concept is displayed in a larger font.</li> </ol>"},{"location":"vis/concept-dependency-graph/#sample-prompt","title":"Sample Prompt","text":"<pre><code>Generate a vis.js application that shows what concepts must\nbe mastered before you understand Ohm's Law.\n\nUse this graph data:\n\n// create an array with nodes\n    var nodes = new vis.DataSet([\n        {id: 1, label: \"Ohm's Law\", color: \"wheat\", size: 150, x: 150, y: 0, fixed: true,font: { size: 24 }, color: {border: \"black\"}},\n        {id: 2, label: 'Voltage', color: \"tan\"},\n        {id: 3, label: 'Current', color: \"tan\"},\n        {id: 4, label: 'Resistance', color: \"tan\"},\n        {id: 5, label: 'Linear Equations', color: \"coral\", shape: \"box\", x: -150, y: 0, fixed: true}\n    ]);\n\n    // create an array with edges\n    var edges = new vis.DataSet([\n        {from: 1, to: 2, arrows: 'to', label: 'DEPENDS_ON' },\n        {from: 1, to: 3, arrows: 'to', label: 'DEPENDS_ON' },\n        {from: 1, to: 4, arrows: 'to', label: 'DEPENDS_ON' },\n        {from: 1, to: 5, arrows: 'to', label: 'DEPENDS_ON' }\n    ]);\n</code></pre>"},{"location":"vis/lab-01/","title":"Vis Tutorial 1","text":"<p>Lab 1</p> <pre><code>&lt;html&gt;\n&lt;head&gt;\n    &lt;script type=\"text/javascript\" src=\"https://unpkg.com/vis-network/standalone/umd/vis-network.min.js\"&gt;&lt;/script&gt;\n\n    &lt;style type=\"text/css\"&gt;\n        #mynetwork {\n            width: 300px;\n            height: 300px;\n            background-color: aliceblue;\n            border: 1px solid silver;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div id=\"mynetwork\"&gt;&lt;/div&gt;\n&lt;a href=\"lab-01\"&gt;Back to Lesson&lt;/a&gt;\n&lt;script type=\"text/javascript\"&gt;\n    // create an array with nodes\n    var nodes = new vis.DataSet([\n        {id: 1, label: 'Node 1'},\n        {id: 2, label: 'Node 2'},\n        {id: 3, label: 'Node 3'},\n        {id: 4, label: 'Node 4'},\n        {id: 5, label: 'Node 5'}\n    ]);\n\n    // create an array with edges\n    var edges = new vis.DataSet([\n        {from: 1, to: 3},\n        {from: 1, to: 2},\n        {from: 2, to: 4},\n        {from: 2, to: 5}\n    ]);\n\n    // create a network\n    var container = document.getElementById('mynetwork');\n\n    // provide the data in the vis format\n    var data = {\n        nodes: nodes,\n        edges: edges\n    };\n    var options = {};\n\n    // initialize your network!\n    var network = new vis.Network(container, data, options);\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"vis/lab-02/","title":"Lab 2: JSON","text":"<p>Run Lab 2</p>"},{"location":"vis/lab-02/#prompt","title":"Prompt","text":"<pre><code>Refactor the attached vis.js program to read the data\nfrom a file called \"lab-02.json\" and store\nthe JavaScript in a separate file called lab-02.js\n</code></pre>"},{"location":"vis/lab-02/#chatgpt-4o-response","title":"ChatGPT 4o Response","text":"<p>To refactor your <code>lab-01.html</code> file, we can follow these steps:</p> <ol> <li>Move the JavaScript code to a separate file called <code>lab-02.js</code>.</li> <li>Fetch the node and edge data from a separate <code>lab-02.json</code> file.</li> <li>Refactor the HTML to reference the new JavaScript file and load the JSON data dynamically.</li> </ol> <p>Here is how we can structure the files:</p>"},{"location":"vis/lab-02/#refactored-html-lab-01html","title":"Refactored HTML (<code>lab-01.html</code>):","text":"<pre><code>&lt;html&gt;\n&lt;head&gt;\n    &lt;script type=\"text/javascript\" src=\"https://unpkg.com/vis-network/standalone/umd/vis-network.min.js\"&gt;&lt;/script&gt;\n    &lt;script type=\"text/javascript\" src=\"network.js\"&gt;&lt;/script&gt;\n\n    &lt;style type=\"text/css\"&gt;\n        #mynetwork {\n            width: 600px;\n            height: 400px;\n            border: 1px solid lightgray;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div id=\"mynetwork\"&gt;&lt;/div&gt;\n&lt;a href=\"lab-01\"&gt;Back to Lesson&lt;/a&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"vis/lab-02/#javascript-lab-02js","title":"JavaScript (<code>lab-02.js</code>):","text":"<pre><code>// Fetch data from the JSON file\nfetch('lab-02.json')\n    .then(response =&gt; response.json())\n    .then(data =&gt; {\n        // Parse the data from JSON\n        const nodes = new vis.DataSet(data.nodes);\n        const edges = new vis.DataSet(data.edges);\n\n        // Create a network\n        const container = document.getElementById('mynetwork');\n        const networkData = {\n            nodes: nodes,\n            edges: edges\n        };\n        const options = {};\n\n        // Initialize the network\n        const network = new vis.Network(container, networkData, options);\n    })\n    .catch(error =&gt; console.error('Error loading the network data:', error));\n</code></pre>"},{"location":"vis/lab-02/#json-file-lab-01json","title":"JSON File (<code>lab-01.json</code>):","text":"<pre><code>{\n    \"nodes\": [\n        {\"id\": 1, \"label\": \"Node 1\"},\n        {\"id\": 2, \"label\": \"Node 2\"},\n        {\"id\": 3, \"label\": \"Node 3\"},\n        {\"id\": 4, \"label\": \"Node 4\"},\n        {\"id\": 5, \"label\": \"Node 5\"}\n    ],\n    \"edges\": [\n        {\"from\": 1, \"to\": 3},\n        {\"from\": 1, \"to\": 2},\n        {\"from\": 2, \"to\": 4},\n        {\"from\": 2, \"to\": 5}\n    ]\n}\n</code></pre>"},{"location":"vis/lab-02/#explanation","title":"Explanation:","text":"<ul> <li>The HTML file now only includes the necessary script tags and references the new JavaScript file (<code>network.js</code>).</li> <li>The <code>network.js</code> script fetches the data from <code>lab-01.json</code> and initializes the network once the data is loaded.</li> <li>The <code>lab-01.json</code> file contains the nodes and edges in a format that can be easily fetched and parsed in JavaScript.</li> </ul> <p>With this refactor, your data can now be dynamically loaded from the JSON file, and your JavaScript code is cleanly separated from the HTML.</p>"},{"location":"vis/lab-03/","title":"Vis Tutorial Lesson 3: Node Properties","text":"<p>Run Lab 3 HTML</p> <p>In this lab we learn how to change the properties of each node including:</p> <ol> <li>The shape</li> <li>The background color</li> <li>The size</li> <li>The font color</li> </ol>"},{"location":"vis/lab-03/#prompt","title":"Prompt","text":"<pre><code>Refactor the attached vis.js to add color and shape to each vertex.\n\nNode 1: red triangle\nNode 2: orange square\nNode 3: gold circle\nNode 4: green big box\nNode 5: blue star\nNode 6: purple ellipse\n</code></pre>"},{"location":"vis/lab-03/#chatgpt-o4-response","title":"ChatGPT o4 Response","text":"<p>To refactor the <code>lab-02</code> files to add color and shape to each vertex, we will modify the <code>lab-02.json</code> to include the color and shape properties for each node. Here's how we can adjust the structure:</p>"},{"location":"vis/lab-03/#updated-lab-03json","title":"Updated <code>lab-03.json</code>:","text":"<pre><code>{\n    \"nodes\": [\n        {\"id\": 1, \"label\": \"Node 1\", \"color\": \"red\", \"shape\": \"triangle\"},\n        {\"id\": 2, \"label\": \"Node 2\", \"color\": \"orange\", \"shape\": \"square\"},\n        {\"id\": 3, \"label\": \"Node 3\", \"color\": \"gold\", \"shape\": \"circle\"},\n        {\"id\": 4, \"label\": \"Node 4\", \"color\": \"green\", \"shape\": \"box\", \"size\": 50},\n        {\"id\": 5, \"label\": \"Node 5\", \"color\": \"blue\", \"shape\": \"star\"},\n        {\"id\": 6, \"label\": \"Node 6\", \"color\": \"purple\", \"shape\": \"ellipse\"}\n    ],\n    \"edges\": [\n        {\"from\": 1, \"to\": 3},\n        {\"from\": 1, \"to\": 2},\n        {\"from\": 2, \"to\": 4},\n        {\"from\": 2, \"to\": 5},\n        {\"from\": 3, \"to\": 6}\n    ]\n}\n</code></pre>"},{"location":"vis/lab-03/#updated-lab-03js","title":"Updated <code>lab-03.js</code>:","text":"<p>You don't need to change much in the JavaScript file, but here it is for completeness.</p> <pre><code>// Fetch data from the JSON file\nfetch('lab-03.json')\n    .then(response =&gt; response.json())\n    .then(data =&gt; {\n        // Parse the data from JSON\n        const nodes = new vis.DataSet(data.nodes);\n        const edges = new vis.DataSet(data.edges);\n\n        // Create a network\n        const container = document.getElementById('mynetwork');\n        const networkData = {\n            nodes: nodes,\n            edges: edges\n        };\n        const options = {};\n\n        // Initialize the network\n        const network = new vis.Network(container, networkData, options);\n    })\n    .catch(error =&gt; console.error('Error loading the network data:', error));\n</code></pre>"},{"location":"vis/lab-03/#changes-explained","title":"Changes explained:","text":"<ul> <li>Each node now has a <code>color</code> and <code>shape</code> property. These properties allow you to customize the appearance of each node.</li> <li>For node 4, a larger size is specified with the <code>size</code> property to make it a \"big box.\"</li> <li>The edges are unchanged but include a new edge between nodes 3 and 6 to reflect the inclusion of Node 6.</li> </ul> <p>When you run this, each node will now have the specified color and shape, creating a visually distinct network.</p>"},{"location":"vis/lab-03/#using-white-text-on-dark-colors","title":"Using White Text On Dark Colors","text":""},{"location":"vis/lab-03/#prompt_1","title":"Prompt","text":"<pre><code>The black text is hard to read on the darker colors. How do I change the text to be white in the green and purple nodes?\n</code></pre>"},{"location":"vis/lab-03/#chatgpt-said","title":"ChatGPT said:","text":"<p>ChatGPT</p> <p>To change the text color for nodes with darker background colors like blue and purple, you can use the <code>font</code> property within each node's configuration to specify the text color. Here's how you can update your <code>lab-03.json</code> file to set the text color to white for the green and purple nodes:</p>"},{"location":"vis/lab-03/#updated-lab-02json","title":"Updated <code>lab-02.json</code>:","text":"<pre><code>{\n    \"nodes\": [\n        {\"id\": 1, \"label\": \"Node 1\", \"color\": \"red\", \"shape\": \"triangle\"},\n        {\"id\": 2, \"label\": \"Node 2\", \"color\": \"orange\", \"shape\": \"square\"},\n        {\"id\": 3, \"label\": \"Node 3\", \"color\": \"yellow\", \"shape\": \"circle\"},\n        {\"id\": 4, \"label\": \"Node 4\", \"color\": \"green\", \"shape\": \"box\", \"size\": 50, \"font\": {\"color\": \"white\"}},\n        {\"id\": 5, \"label\": \"Node 5\", \"color\": \"blue\", \"shape\": \"star\"},\n        {\"id\": 6, \"label\": \"Node 6\", \"color\": \"purple\", \"shape\": \"ellipse\", \"font\": {\"color\": \"white\"}}\n    ],\n    \"edges\": [\n        {\"from\": 1, \"to\": 3},\n        {\"from\": 1, \"to\": 2},\n        {\"from\": 2, \"to\": 4},\n        {\"from\": 2, \"to\": 5},\n        {\"from\": 3, \"to\": 6}\n    ]\n}\n</code></pre>"},{"location":"vis/lab-03/#explanation","title":"Explanation:","text":"<ul> <li>For <code>Node 5</code> (blue) and <code>Node 6</code> (purple), I added the <code>\"font\": {\"color\": \"white\"}</code> property, which changes the text color to white for better readability against the darker backgrounds.</li> </ul> <p>Now, when you display the graph, the text on the blue and purple nodes will appear in white, making it much easier to read.</p>"},{"location":"vis/lab-03/#more-things-to-try","title":"More Things to Try","text":"<p>You can also change the border width:</p> <ol> <li>borderWidth</li> <li>color.border</li> <li>opacity</li> <li>icon</li> <li>image</li> </ol> <p>The size is used to determine the size of node shapes that do not have the label inside of them. These shapes are: image, circularImage, diamond, dot, star, triangle, triangleDown, hexagon, square and icon</p>"},{"location":"vis/lab-03/#custom-canvas-shapes","title":"Custom Canvas Shapes","text":"<p>You can make the shape \"custom\" and then supply a Canvas drawing function:</p> <p>Canvas Drawing Function</p>"},{"location":"vis/lab-03/#references","title":"References","text":"<p>Vis.js Documentation on Node Properties</p>"},{"location":"vis/lab-04/","title":"Lab 4: Edge Properties","text":"<p>Lab 4 Edge HTML</p> <p>Here's a small example of a <code>vis.js</code> program that shows edge properties:</p> <ol> <li>Edge Labels</li> <li>Edge Color</li> <li>Edge Width</li> <li>Edge Dashes</li> <li>Color Opacity</li> <li>Hover Color</li> <li>Highlight Color</li> <li>Arrows</li> </ol>"},{"location":"vis/lab-04/#javascript-code","title":"JavaScript Code:","text":"<pre><code>// Fetch data from the JSON file\nfetch('lab-04.json')\n    .then(response =&gt; response.json())\n    .then(data =&gt; {\n        // Parse the data from JSON\n        const nodes = new vis.DataSet(data.nodes);\n\n        // Define edges with additional properties\n        const edges = new vis.DataSet([\n            { from: 1, to: 3, label: 'Edge 1-3', color: { color: 'red' }, \n               width: 2, arrows: 'to' },\n            { from: 1, to: 2, label: 'Edge 1-2', color: { color: 'blue', \n               highlight: 'purple' }, width: 3, \n               arrows: { to: { enabled: true, type: 'arrow' }, \n               from: { enabled: true, type: 'circle' } } },\n            { from: 2, to: 4, label: 'Edge 2-4', color: { color: 'green' }, \n            width: 3, dashes: true },\n            { from: 2, to: 5, label: 'Edge 2-5', color: { color: 'orange', \n            hover: 'yellow' }, width: 4, arrows: 'middle' },\n            { from: 3, to: 6, label: 'Edge 3-6', \n            color: { color: 'purple', opacity: 0.7 }, \n            width: 2, arrows: 'to' }\n        ]);\n\n        // Create a network\n        const container = document.getElementById('mynetwork');\n        const networkData = {\n            nodes: nodes,\n            edges: edges\n        };\n\n        const options = {\n            edges: {\n                font: {\n                    size: 14,\n                    color: 'black',\n                    align: 'horizontal'\n                },\n                smooth: {\n                    type: 'cubicBezier',\n                    forceDirection: 'horizontal',\n                    roundness: 0.4\n                }\n            }\n        };\n\n        // Initialize the network\n        const network = new vis.Network(container, networkData, options);\n    })\n    .catch(error =&gt; console.error('Error loading the network data:', error));\n</code></pre>"},{"location":"vis/lab-04/#instructions-for-use","title":"Instructions for Use:","text":"<ol> <li>HTML Setup: We use lab-04.html to load this new script.</li> <li>Edge Configuration: Each edge is customized to demonstrate properties like:<ul> <li>Label: Displays a label on each edge.</li> <li>Color: Sets custom colors and highlights.</li> <li>Width: Adjusts the thickness of edges.</li> <li>Arrows: Adds directional arrows with different placements.</li> </ul> </li> </ol> <p>This setup offers a variety of options for exploring edge properties in vis.js networks.</p>"},{"location":"vis/lab-05/","title":"Lab 5: Custom Shape","text":"<p>Lab 5 Custom Shapes HTML</p> <p>Here's a small example of a <code>vis.js</code> program that uses the <code>ctxRenderer</code> function to draw a custom hexagonal shape for a node:</p>"},{"location":"vis/lab-05/#html-code","title":"HTML Code:","text":"<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;title&gt;vis.js Custom Shape Example&lt;/title&gt;\n    &lt;script type=\"text/javascript\" src=\"https://unpkg.com/vis-network/standalone/umd/vis-network.min.js\"&gt;&lt;/script&gt;\n    &lt;style type=\"text/css\"&gt;\n        #mynetwork {\n            width: 600px;\n            height: 400px;\n            border: 1px solid lightgray;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div id=\"mynetwork\"&gt;&lt;/div&gt;\n\n&lt;script&gt;\n    function customShapeRenderer({ ctx, x, y, state: { selected, hover }, style }) {\n        const r = style.size;  // size of the shape (radius)\n        ctx.beginPath();\n        const sides = 6;  // number of sides for the hexagon\n        const a = (Math.PI * 2) / sides;  // angle between sides\n\n        // Start drawing the hexagon\n        ctx.moveTo(x + r * Math.sin(0), y + r * Math.cos(0));\n        for (let i = 1; i &lt;= sides; i++) {\n            ctx.lineTo(x + r * Math.sin(a * i), y + r * Math.cos(a * i));\n        }\n\n        ctx.closePath();\n        ctx.save();\n        ctx.fillStyle = selected ? 'blue' : 'red';  // change color if selected\n        ctx.fill();\n        ctx.strokeStyle = hover ? 'orange' : 'black';  // change stroke if hovered\n        ctx.stroke();\n        ctx.restore();\n\n        // Add label inside the shape\n        ctx.font = \"normal 12px sans-serif\";\n        ctx.fillStyle = 'black';\n        ctx.fillText('Custom Node', x - r / 2, y + 4);\n\n        // Return dimensions of the node\n        return {\n            nodeDimensions: { width: r * 2, height: r * 2 }\n        };\n    }\n\n    // Create nodes and edges\n    const nodes = new vis.DataSet([\n        {\n            id: 1,\n            label: 'Custom Node',\n            shape: 'custom',\n            ctxRenderer: customShapeRenderer,  // specify the custom renderer\n            size: 40  // set the size of the node\n        }\n    ]);\n\n    const edges = new vis.DataSet([]);\n\n    // Create the network\n    const container = document.getElementById('mynetwork');\n    const data = {\n        nodes: nodes,\n        edges: edges\n    };\n    const options = {};\n    const network = new vis.Network(container, data, options);\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"vis/lab-05/#explanation","title":"Explanation:","text":"<ul> <li>Custom Renderer (<code>customShapeRenderer</code>): This function creates a hexagonal node. It takes the context (<code>ctx</code>) and node state as input, calculates the position of each side of the hexagon, and draws the shape using the <code>canvas</code> API.<ul> <li>The node is filled with red unless it is selected, in which case it becomes blue.</li> <li>The stroke color is black but changes to orange when the node is hovered over.</li> <li>The label \"Custom Node\" is drawn inside the hexagon.</li> </ul> </li> <li>Node Configuration: The node uses the <code>shape: 'custom'</code> property to specify that it should use a custom renderer. The <code>ctxRenderer</code> property is set to the <code>customShapeRenderer</code> function.</li> <li>Node Dimensions: The size of the hexagonal node is defined by the <code>r</code> variable, which is passed in via <code>style.size</code>.</li> </ul> <p>When you load this HTML file in a browser, it will draw a single hexagonal node with the ability to change color when selected or hovered. You can easily modify the shape or style further by changing the drawing logic inside the <code>customShapeRenderer</code> function.</p> <p>4o</p> <p>requestAnimationFrame((function(){window.__oai_logTTI?window.__oai_logTTI():window.__oai_SSR_TTI=window.__oai_SSR_TTI??Date.now()}))</p> <p>ChatGPT can make mistakes. Check important info.</p>"},{"location":"vis/csv-reader/","title":"CSV to JSON Converter","text":"<p>This prompt generates a Python program that reads in a CSV file for a graph and returns a JSON file in vis.js format.</p>"},{"location":"vis/csv-reader/#prompt","title":"Prompt","text":"<pre><code>I have a CSV file that has graph data in it.\n\nThe fields are:\nConceptID - the node id in a graph. Unique for all nodes. Required.\nThe ConceptName - a node label - Required\nDependencyList - a pipe-delimited list of dependant ConceptIDs.  An edge goes from this concept to other concepts with a directed arrow.\nCategoryID - a group ID for the concept.\nCategoryLabel - the name of the category\n\nThere are about 11 Categories\n\nConceptID,ConceptName,DependencyList,CategoryID,CategoryLabel\n1,Ohm's Law,2|3|4,1,Fundamental Concepts\n2,Voltage,7,1,Fundamental Concepts\n3,Current,7,1,Fundamental Concepts\n4,Resistance,101,1,Fundamental Concepts\n5,Power,2|3,1,Fundamental Concepts\n6,Energy,5|102,1,Fundamental Concepts\n7,Electric charge,120,1,Fundamental Concepts\n8,Conductors,7,1,Fundamental Concepts\n9,Insulators,7,1,Fundamental Concepts\n10,Capacitance,2|7,1,Fundamental Concepts\n11,Inductance,3|104,1,Fundamental Concepts\n\nPlease create a Python program that converts this CSV file into a JSON file that can be easily read by vis.js.  Assume that the category ID will become a group ID.\n</code></pre>"},{"location":"vis/csv-reader/#chatgpt-response","title":"ChatGPT Response","text":"<pre><code>import csv\nimport json\n\ndef csv_to_visjs_json(csv_filename, json_filename):\n    nodes = []\n    edges = []\n    categories = {}\n\n    # Read the CSV file\n    with open(csv_filename, 'r', newline='', encoding='utf-8') as csvfile:\n        reader = csv.DictReader(csvfile)\n        for row in reader:\n            # Extract node information\n            try:\n                concept_id = int(row['ConceptID'])\n            except ValueError:\n                print(f\"Invalid ConceptID '{row['ConceptID']}' skipped.\")\n                continue  # Skip rows with invalid ConceptID\n\n            concept_name = row['ConceptName'].strip()\n            if not concept_name:\n                print(f\"Empty ConceptName for ConceptID {concept_id} skipped.\")\n                continue  # Skip nodes without a name\n\n            try:\n                category_id = int(row['CategoryID'])\n            except ValueError:\n                print(f\"Invalid CategoryID '{row['CategoryID']}' for ConceptID {concept_id} skipped.\")\n                continue  # Skip rows with invalid CategoryID\n\n            category_label = row['CategoryLabel'].strip()\n\n            # Create node object\n            node = {\n                'id': concept_id,\n                'label': concept_name,\n                'group': category_id\n            }\n            nodes.append(node)\n\n            # Store category information (optional, for groups)\n            if category_id not in categories:\n                categories[category_id] = category_label\n\n            # Process DependencyList to create edges\n            dependency_list = row['DependencyList'].strip()\n            if dependency_list:\n                dependencies = dependency_list.split('|')\n                for dep in dependencies:\n                    dep = dep.strip()\n                    if dep:\n                        try:\n                            dep_id = int(dep)\n                            edge = {\n                                'from': concept_id,\n                                'to': dep_id\n                            }\n                            edges.append(edge)\n                        except ValueError:\n                            print(f\"Invalid DependencyID '{dep}' for ConceptID {concept_id} skipped.\")\n                            continue  # Skip invalid DependencyIDs\n\n    # Optionally, create a separate groups structure if needed\n    # Uncomment the following lines if you want to include group labels\n    \"\"\"\n    groups = []\n    for cid, clabel in categories.items():\n        group = {\n            'id': cid,\n            'label': clabel\n            # You can add more styling options here if needed\n        }\n        groups.append(group)\n    data = {\n        'nodes': nodes,\n        'edges': edges,\n        'groups': groups\n    }\n    \"\"\"\n\n    # If not using separate groups, omit the 'groups' key\n    data = {\n        'nodes': nodes,\n        'edges': edges\n    }\n\n    # Write the JSON output\n    with open(json_filename, 'w', encoding='utf-8') as jsonfile:\n        json.dump(data, jsonfile, indent=4)\n\n    print(f\"Successfully converted '{csv_filename}' to '{json_filename}'.\")\n\nif __name__ == \"__main__\":\n    # Define input and output file names\n    input_csv = 'graph-data.csv'\n    output_json = 'graph-data.json'\n\n    # Convert CSV to JSON\n    csv_to_visjs_json(input_csv, output_json)\n</code></pre> <p>Python Code</p>"},{"location":"vis/fix-x-positions/","title":"Fix the X Positions","text":""},{"location":"vis/fix-x-positions/#left-to-right-concept-graphs","title":"Left to Right Concept Graphs","text":"<p>In this lesson, we learn how to control the X placement of both the foundational concepts to the left of a concept dependency graph and goals to the right of the network.  This allows us to consistently view a learning graph from prerequisite concepts on the left and goals on the right.</p>"},{"location":"vis/fix-x-positions/#order-of-labs","title":"Order of Labs","text":"<p>Our first examples will manually have us label each of the nodes that disable the physics for x-placement of the nodes in the correct locations.  Later, we show that you can add a JavaScript function that will automatically apply placement rules to nodes in groups. This make preparing data much simpler.</p>"},{"location":"vis/fix-x-positions/#background-on-the-physics-of-springs","title":"Background on the Physics of Springs","text":"<p>To place nodes on a 2-dimensional surface so they are automatically spread apart, we simulated the forces on springs.  The springs will pull connected nodes closer together on the drawing canvas, but not so close that they get stacked on top of each other or overlap too much.</p> <p>Here is how the JSON data will look to disable the X movement:</p> <pre><code>{\n    \"nodes\": [\n      { \"id\": 1, \"label\": \"Foundation 1\", \"shape\": \"box\", \"group\": 1, \n        \"x\": -400, \"y\": -200, \n        \"fixed\": { \"x\": true, \"y\": false }, \"physics\": false },\n      { \"id\": 2, \"label\": \"Foundation 2\", \"shape\": \"box\", \"group\": 1, \n        \"x\": -400, \"y\": -150, \n        \"fixed\": { \"x\": true, \"y\": false }, \"physics\": false },\n      { \"id\": 3, \"label\": \"Foundation 3\", \"shape\": \"box\", \"group\": 1, \n        \"x\": -400, \"y\": -100, \n        \"fixed\": { \"x\": true, \"y\": false }, \"physics\": false },\n]}\n</code></pre> <p>The foundation concepts above must be placed on the left edge, around x=-400. But we want to also prevent their X locations from getting moved. So we use the <code>fixed</code> option and indicate that only the x element is fixed.</p>"},{"location":"vis/fix-x-positions/#use-of-visjs-group-property","title":"Use of Vis.js Group Property","text":"<p>Vis.js allows each node in a graph to belong to a single group.  By convention, we use group 1 as the group for all Foundation Concepts. We also use group 12 for goal concepts, since that is a good number to set as the maximum dependency level to reach a goal within a course.</p> <p>By convention, any concepts that only depend on a Foundation Concept are considered to be in level 2 concepts.  If a concept depends on a level 2 concept it is called a level 3 concept.  In these demos, we will be using a group number that indicates the group number = (number of hops +1) from a foundation concept.</p> <p>Fix X Positions Demo</p> <p>Warning</p> <p>We must also disable the <code>Improved Layout</code> which attempts to prevent overlap of the nodes.  Unfortunately, when we use fixed positioning on some nodes this causes conflicts.</p> <pre><code>options: {\n   physics: { ...\n   },\n   layout: {\n        \"improvedLayout\": false, // Prevent node overlap\n  }\n}\n</code></pre>"},{"location":"vis/fix-x-positions/#simple-demo","title":"Simple Demo","text":"<p>Simple Demo</p>"},{"location":"vis/fix-x-positions/#lab-2-loading-from-json","title":"Lab 2 - Loading From JSON","text":"<p>In this lab, we successfully load our graph data from this graph.json file, but the nodes placement and instructions to disable the physics is ignored.</p> <p>Fix X Positions V2 </p> <p>Fix X Positions V3</p> <p>Fix X Positions V4</p> <p>Fix X Positions V5</p> <p>Fix X Positions V6 - where group 1 and group 12 have their X positions pinned to x=-1000 and x=1000 respectively.</p> <p>The code that fixes the x positions for nodes in groups 1 and 12 is executed immediately after the nodes are created. Since the function is written within a forEach loop right after the nodes are defined, it runs automatically when the script is loaded. No explicit function call is needed because the function is not declared separately; it is an inline anonymous function applied to the nodes directly.</p> <p>Fix X Positions V7 - where we shorten distance between the left and right x positions to be 500, not 1000.</p> <p>An alternative that might be easier to work with is to create a function that fixes the left and right nodes:</p> <pre><code>// Function to fix x positions for specific groups\nfunction fixXPositions(nodes) {\n    nodes.forEach(function (node) {\n        if (node.group === 1) {\n            node.x = -500;\n            node.fixed = { x: true, y: false }; // Fix x, but let y be adjusted by physics\n        } else if (node.group === 12) {\n            node.x = 500;\n            node.fixed = { x: true, y: false }; // Fix x, but let y be adjusted by physics\n        }\n    });\n}\n\n// After defining nodes, call the function\nfixXPositions(nodes);\n</code></pre> <p>Fix X Positions V8 -</p>"},{"location":"vis/fix-x-positions/#prompt","title":"Prompt","text":"<pre><code>using vis.js, is there a way to freeze a node's x position\nbut let the y position float freely and be repositioned\nby the force-directed graph algorithm?\n</code></pre>"},{"location":"vis/fix-x-positions/#chatgpt-said","title":"ChatGPT said:","text":"<p>In vis.js, the built-in options for node positioning allow you to fix both the x and y coordinates of a node using the <code>fixed</code> option. However, freezing only one axis while letting the other float (like freezing the x-axis and letting the y-axis adjust with the force-directed graph algorithm) is not supported natively.</p> <p>That said, you can achieve this behavior with a workaround by using the <code>physics</code> option and manually adjusting the node's x position in each frame:</p> <ol> <li>Set the node's <code>x</code> position and use the <code>fixed: { x: true, y: false }</code> option to lock only the x-axis.</li> <li>During the graph's update cycle, reapply the node's fixed x position while letting the force algorithm adjust the y position.</li> </ol> <p>Here's an example code snippet to implement this behavior:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;title&gt;vis.js Fixed X Position Example&lt;/title&gt;\n  &lt;script type=\"text/javascript\" src=\"https://unpkg.com/vis-network@9.1.2/dist/vis-network.min.js\"&gt;&lt;/script&gt;\n\n  &lt;style&gt;\n    #network {\n      width: 800px;\n      height: 600px;\n      border: 1px solid lightgray;\n      margin-left: 10px;\n      background-color: aliceblue;\n    }\n  &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div id=\"network\"&gt;&lt;/div&gt;\n&lt;script type=\"text/javascript\" src=\"fix-x-positions.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <pre><code>var nodes = new vis.DataSet([\n  { id: 1, label: \"Node 1\", x: 100, fixed: { x: true, y: false } },\n  { id: 2, label: \"Node 2\", x: 200, fixed: { x: true, y: false } },\n  { id: 3, label: \"Node 3\", fixed: false },\n]);\n\nvar edges = new vis.DataSet([\n  { from: 1, to: 2 },\n  { from: 2, to: 3 },\n]);\n\nvar container = document.getElementById('network');\nvar data = {\n  nodes: nodes,\n  edges: edges\n};\n\nvar options = {\n  physics: {\n    enabled: true,\n    solver: 'forceAtlas2Based',\n    stabilization: false\n  }\n};\n\nvar network = new vis.Network(container, data, options);\n\n// Workaround: Lock x position while letting y position be free\nnetwork.on(\"beforeDrawing\", function () {\n  nodes.forEach(function (node) {\n    if (node.fixed &amp;&amp; node.fixed.x) {\n      var currentPosition = network.getPosition(node.id);\n      nodes.update({ id: node.id, x: node.x, y: currentPosition.y });\n    }\n  });\n});\n</code></pre>"},{"location":"vis/fix-x-positions/#explanation-of-changes","title":"Explanation of Changes","text":"<ol> <li> <p>Fixed Nodes Configuration:</p> <ul> <li><code>fixed: { x: true, y: false }</code>: This ensures that the x-position of the node remains constant while allowing the y-position to be influenced by the physics engine.</li> <li><code>physics: false</code>: Disables physics simulation for these nodes, preventing them from being moved by forces or other nodes.</li> <li> <p>Removal of <code>beforeDrawing</code> Event:</p> </li> <li> <p>Since we're now using <code>physics: false</code> for fixed nodes, the manual adjustment in the <code>beforeDrawing</code> event is no longer necessary and has been removed to prevent interference.</p> </li> <li> <p>Centering the Graph:</p> </li> <li> <p><code>moveTo</code> Method: After the network stabilizes, <code>moveTo</code> centers the graph at (0,0) with a smooth animation.</p> </li> <li><code>stabilization</code> Settings: Increased the number of iterations to ensure the network has ample time to stabilize before centering.</li> <li> <p>Responsive Design:</p> </li> <li> <p>Window Resize Event: Added an event listener to re-fit the network when the browser window is resized, maintaining the centered view.</p> </li> <li> <p>Node Styling (Optional):</p> </li> <li> <p>Enhanced node appearance for better visibility and aesthetics. This is optional but can help in visual differentiation.</p> </li> </ul> </li> </ol>"},{"location":"vis/fix-x-positions/#additional-tips","title":"Additional Tips","text":"<ul> <li> <p>Adjust Initial Positions: Ensure that the initial <code>x</code> positions of the fixed nodes are within the visible range of your container. If nodes are still drifting off, try setting <code>x</code> to smaller absolute values (e.g., closer to 0).</p> </li> <li> <p>Scale Adjustment: If the graph appears too zoomed out or in, adjust the <code>scale</code> parameter in the <code>moveTo</code> method to better fit the nodes within the view.</p> </li> <li> <p>Solver Selection: While <code>forceAtlas2Based</code> is a good general-purpose solver, experimenting with different solvers like <code>barnesHut</code> or <code>repulsion</code> might yield better results based on your specific graph structure.</p> </li> <li> <p>Debugging Node Positions: Temporarily disable physics (<code>physics: false</code>) for all nodes to manually position them and ensure they appear correctly within the view. Once satisfied, re-enable physics selectively.</p> </li> </ul>"},{"location":"vis/fix-x-positions/#final-thoughts","title":"Final Thoughts","text":"<p>By configuring the fixed nodes correctly and ensuring they are excluded from the physics simulation, you should achieve the desired behavior where specific nodes remain anchored on the x-axis while others are dynamically positioned. Centering the graph post-stabilization ensures that all nodes remain within the visible area, providing a clear and organized visualization.</p> <p>Feel free to adjust the parameters further based on the specific requirements of your graph and the visual outcome you desire. Let me know if you encounter any more issues or need further assistance!</p>"},{"location":"vis/graph-editor/","title":"Graph Editor","text":"<p>Run Graph Editor</p>"},{"location":"vis/graph-editor/#prompt","title":"Prompt","text":"<pre><code>Please generate a graph network editor based on vis.js.  The editor should be able to do the following:\n\n1. Open a graph network from a JSON file to an in memory structure.  Look for files with .json extensions.\n2. Add, update and delete nodes and edges.\n3. Edit various properties of the nodes and edges such as color, shape, size and image\n4. Save the in-memory structure to the file or do a \"Save As\" to a new file\n5. Allow the user to change and save global options\n\nUpon reading the file, display statistics about what was in the file including node count and edge count.  Also display the count of orphaned nodes when a file is read.\nPerform checks on data quality as a new file is opened such as edges without nodes.\n</code></pre>"},{"location":"vis/graph-editor/#graph-editor-check-for-network","title":"Graph Editor Check for Network","text":"<p>Check for Network after Load of JSON data</p>"},{"location":"vis/graph-editor/#references","title":"References","text":"<p>Sam Adams TinkerTiny Vis.js Graph Editor - an interesting UI.  One time code commit in 2022.</p>"},{"location":"vis/graph-editor/prompt-history/","title":"Prompt History for Graph Editor","text":""},{"location":"vis/graph-editor/prompt-history/#adding-details-to-node","title":"Adding Details to Node","text":"<p>``` What are the most common properties that a user sets on a node? I can think of the following:  1. Label  2. Title (for hover text)  3. Shape (selected from a list of shapes)  4. Size  5. Background color (select from list)  6. Edge color (select from list)  7. x  8. y  9. Fixed location (checkbox) </p> <p>What other parameters might a person change? Update the JavaScript to allow all these parameters to be visible when creating a new node or updating a node.</p>"},{"location":"vis/graph-editor/prompt-history/#chatgpt-said","title":"ChatGPT said:","text":"<p>In addition to the properties you've already listed, here are some other common node properties that users might want to set:</p> <ol> <li>Image (for image-based nodes, with a URL to an image)</li> <li>Font (size, color, face for the label)</li> <li>Border Width (controls the thickness of the node's border)</li> <li>Border Color (set separately from edge color, allows customization of node outline)</li> <li>Opacity (allows transparency on nodes)</li> <li>Shadow (option to add shadows for depth perception)</li> <li>Group (used to assign nodes into categories for different styles or behaviors)</li> <li>Icon (if using icons instead of labels)</li> <li>Physics (whether the node is affected by physics simulation)</li> </ol>"},{"location":"vis/graph-editor/prompt-history/#updated-javascript-for-node-creationediting-form","title":"Updated JavaScript for Node Creation/Editing Form","text":"<p>Here is an updated version of your graph-editor.js that includes a form for setting all these parameters when creating or editing nodes:</p>"},{"location":"vis/graph-viewer/","title":"Graph Viewer","text":"<p>Graph Viewer</p>"},{"location":"vis/learn-python/","title":"Learn Python and Data Science","text":""},{"location":"vis/learn-python/#prompt","title":"Prompt","text":"<p>Create a graph in vis.js format for learning data science with Python. Make Learn Python the first Concept, but then make that a prerequsite to many Python data science packages like NumPi, SciKitLearn, PyTourch etc.</p>"},{"location":"vis/learn-python/#chatgpt-said","title":"ChatGPT said:","text":"<p>ChatGPT</p> <p>Here is an example of a vis.js graph configuration representing a learning graph for data science with Python. The first concept is \"Learn Python,\" which is a prerequisite for various Python data science packages like NumPy, SciKitLearn, and PyTorch.</p> <pre><code>javascript\nCopy code\n\n`var nodes = new vis.DataSet([\n  { id: 1, label: \"Learn Python\", title: \"Basic Python Programming\" },\n  { id: 2, label: \"Learn NumPy\", title: \"Numerical computing with Python\" },\n  { id: 3, label: \"Learn Pandas\", title: \"Data manipulation and analysis\" },\n  { id: 4, label: \"Learn Matplotlib\", title: \"Data visualization with Python\" },\n  { id: 5, label: \"Learn SciKitLearn\", title: \"Machine learning with Python\" },\n  { id: 6, label: \"Learn TensorFlow\", title: \"Deep learning with Python\" },\n  { id: 7, label: \"Learn PyTorch\", title: \"Deep learning with Python\" },\n  { id: 8, label: \"Learn Seaborn\", title: \"Statistical data visualization\" },\n  { id: 9, label: \"Learn Statsmodels\", title: \"Statistical models in Python\" },\n]);\n\nvar edges = new vis.DataSet([\n  { from: 1, to: 2, label: \"prerequisite\" },\n  { from: 1, to: 3, label: \"prerequisite\" },\n  { from: 1, to: 4, label: \"prerequisite\" },\n  { from: 1, to: 5, label: \"prerequisite\" },\n  { from: 1, to: 6, label: \"prerequisite\" },\n  { from: 1, to: 7, label: \"prerequisite\" },\n  { from: 1, to: 8, label: \"prerequisite\" },\n  { from: 1, to: 9, label: \"prerequisite\" },\n]);\n\nvar container = document.getElementById(\"mynetwork\");\nvar data = {\n  nodes: nodes,\n  edges: edges,\n};\nvar options = {\n  nodes: {\n    shape: \"box\",\n    size: 20,\n    color: {\n      background: \"#ffffff\",\n      border: \"#000000\",\n    },\n    font: {\n      color: \"#000000\",\n      size: 14,\n    },\n  },\n  edges: {\n    arrows: \"to\",\n    smooth: true,\n  },\n  layout: {\n    hierarchical: {\n      direction: \"LR\", // Left to right layout\n      sortMethod: \"directed\",\n    },\n  },\n};\nvar network = new vis.Network(container, data, options);\n`\n</code></pre>"},{"location":"vis/learn-python/#explanation","title":"Explanation:","text":"<ul> <li>Nodes: Each concept (e.g., \"Learn Python,\" \"Learn NumPy\") is represented as a node.</li> <li>Edges: Each edge represents a prerequisite relationship. The <code>from</code> attribute specifies the starting node (e.g., \"Learn Python\") and the <code>to</code> attribute specifies the dependent concept (e.g., \"Learn NumPy\").</li> <li>Layout: The layout is hierarchical and flows from left to right (LR), with arrows pointing from the prerequisite concept to the dependent concept.</li> </ul>"},{"location":"vis/learn-python/#concepts-flow","title":"Concepts Flow:","text":"<ol> <li>Learn Python is the foundation, required for all other data science packages.</li> <li>NumPy, Pandas, Matplotlib, SciKitLearn, TensorFlow, PyTorch, Seaborn, and Statsmodels are all dependent on a solid understanding of Python.</li> </ol>"},{"location":"vis/legends/","title":"Learning Graph Legends","text":"Image caption <p>A legend is a key that shows you what different shapes, icons, images and colors imply in your learning graphs. There are several ways to place a legend on your learning graph and each method has tradeoffs.</p>"},{"location":"vis/legends/#html-table-legend","title":"HTML Table Legend","text":"<p>HTML tables usually are located in a fixed position of the edge of a graph viewer. They have the benefit of having a regular structure that is easy to align. They can also be configured to appear and disappear if the screen region is needed for viewing the full graph.</p>"},{"location":"vis/legends/#node-legends","title":"Node Legends","text":"<p>https://jsfiddle.net/adgd87/szt7h6kv/19/</p>"},{"location":"vis/node-enricher/","title":"Vis.js Node Enricher Example","text":""},{"location":"vis/node-enricher/#prompt","title":"Prompt","text":"<pre><code>I have a JSON file that represents the nodes and edges in a network graph. I would like you to generate a Python program that reads in this JSON file and returns it with one addition. If the node has a group of 1, I want you to add another property \"x\": -300. \n\nAll other elements in the JSON file should remain unchained. Here is a sample of the nodes: { \"nodes\": \\[ { \"id\": 1, \"label\": \"Ohm's Law\", \"group\": 1 }, { \"id\": 2, \"label\": \"Voltage\", \"group\": 1 }, { \"id\": 3, \"label\": \"Current\", \"group\": 1 }, { \"id\": 4, \"label\": \"Resistance\", \"group\": 1 }, { \"id\": 5, \"label\": \"Power\", \"group\": 1 }, { \"id\": 6, \"label\": \"Energy\", \"group\": 1 } You should return: \"nodes\": \\[ { \"id\": 1, \"label\": \"Ohm's Law\", \"group\": 1, \"x\": 0 } etc.\n</code></pre>"},{"location":"vis/node-enricher/#chatgpt-response","title":"ChatGPT Response","text":"<p>Certainly! Below is a Python program that accomplishes your requirements. This script reads a JSON file representing a network graph, adds an <code>\"x\": -300</code> property to each node with <code>\"group\": 1</code>, and writes the modified data back to a new JSON file. All other elements in the JSON remain unchanged.</p>"},{"location":"vis/node-enricher/#step-by-step-explanation","title":"Step-by-Step Explanation","text":"<ol> <li> <p>Import Necessary Modules:</p> <ul> <li><code>json</code>: To handle JSON data.</li> <li><code>sys</code>: To handle command-line arguments (optional, for flexibility).</li> <li> <p>Define the Functionality:</p> </li> <li> <p>Reading the JSON File: The script reads the input JSON file containing the network graph.</p> </li> <li>Modifying Nodes: It iterates through each node in the <code>\"nodes\"</code> list. If a node has <code>\"group\": 1</code>, it adds a new property <code>\"x\": -300</code> to that node.</li> <li>Writing the Modified JSON: The script writes the updated JSON data to an output file.</li> <li> <p>Usage:</p> </li> <li> <p>You can run the script from the command line, specifying the input and output file paths. If no arguments are provided, it defaults to <code>input.json</code> and <code>output.json</code>.</p> </li> </ul> </li> </ol>"},{"location":"vis/node-enricher/#python-code","title":"Python Code","text":"<pre><code>import json\nimport sys\n\ndef add_x_property(input_file, output_file):\n    try:\n        # Read the input JSON file\n        with open(input_file, 'r', encoding='utf-8') as f:\n            data = json.load(f)\n\n        # Check if 'nodes' key exists\n        if 'nodes' not in data:\n            print(f\"Error: The key 'nodes' was not found in {input_file}.\")\n            return\n\n        # Iterate through each node and add \"x\": -300 if group is 1\n        for node in data['nodes']:\n            if node.get('group') == 1:\n                node['x'] = -300\n\n        # Write the modified data to the output JSON file\n        with open(output_file, 'w', encoding='utf-8') as f:\n            json.dump(data, f, indent=4)\n\n        print(f\"Successfully wrote the modified JSON to {output_file}.\")\n\n    except FileNotFoundError:\n        print(f\"Error: The file {input_file} does not exist.\")\n    except json.JSONDecodeError:\n        print(f\"Error: The file {input_file} is not a valid JSON file.\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\ndef main():\n    # Default input and output file names\n    input_file = 'input.json'\n    output_file = 'output.json'\n\n    # If command-line arguments are provided, use them\n    if len(sys.argv) == 3:\n        input_file = sys.argv[1]\n        output_file = sys.argv[2]\n    elif len(sys.argv) != 1:\n        print(\"Usage: python script.py [input_file output_file]\")\n        return\n\n    add_x_property(input_file, output_file)\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"vis/node-enricher/#how-to-use-the-script","title":"How to Use the Script","text":"<ol> <li> <p>Save the Script:</p> <ul> <li>Save the above code to a file, for example, <code>modify_graph.py</code>.</li> <li> <p>Prepare Your JSON File:</p> </li> <li> <p>Ensure your JSON file (e.g., <code>input.json</code>) is properly formatted. Here's an example based on your sample:</p> <pre><code>json\nCopy code\n\n`{\n    \"nodes\": [\n        {\n            \"id\": 1,\n            \"label\": \"Ohm's Law\",\n            \"group\": 1\n        },\n        {\n            \"id\": 2,\n            \"label\": \"Voltage\",\n            \"group\": 1\n        },\n        {\n            \"id\": 3,\n            \"label\": \"Current\",\n            \"group\": 1\n        },\n        {\n            \"id\": 4,\n            \"label\": \"Resistance\",\n            \"group\": 1\n        },\n        {\n            \"id\": 5,\n            \"label\": \"Power\",\n            \"group\": 1\n        },\n        {\n            \"id\": 6,\n            \"label\": \"Energy\",\n            \"group\": 1\n        }\n    ],\n    \"edges\": [\n        // Your edge definitions here\n    ]\n}\n`\n</code></pre> </li> </ul> </li> <li> <p>Run the Script:</p> <ul> <li> <p>Open your terminal or command prompt.</p> </li> <li> <p>Navigate to the directory containing <code>modify_graph.py</code> and your <code>input.json</code>.</p> </li> <li> <p>Execute the script using Python. You can specify input and output files or use the defaults.</p> <p>Using Default File Names (<code>input.json</code> and <code>output.json</code>):</p> <pre><code>bash\nCopy code\n\n`python modify_graph.py\n`\n</code></pre> <p>Specifying Input and Output Files:</p> <pre><code>bash\nCopy code\n\n`python modify_graph.py your_input.json your_output.json\n`\n</code></pre> </li> </ul> </li> <li> <p>Check the Output:</p> <ul> <li> <p>After running the script, check the <code>output.json</code> file. Nodes with <code>\"group\": 1</code> will have an additional property <code>\"x\": -300</code>.</p> </li> <li> <p>Example Output:</p> <pre><code>json\nCopy code\n\n`{\n    \"nodes\": [\n        {\n            \"id\": 1,\n            \"label\": \"Ohm's Law\",\n            \"group\": 1,\n            \"x\": -300\n        },\n        {\n            \"id\": 2,\n            \"label\": \"Voltage\",\n            \"group\": 1,\n            \"x\": -300\n        },\n        {\n            \"id\": 3,\n            \"label\": \"Current\",\n            \"group\": 1,\n            \"x\": -300\n        },\n        {\n            \"id\": 4,\n            \"label\": \"Resistance\",\n            \"group\": 1,\n            \"x\": -300\n        },\n        {\n            \"id\": 5,\n            \"label\": \"Power\",\n            \"group\": 1,\n            \"x\": -300\n        },\n        {\n            \"id\": 6,\n            \"label\": \"Energy\",\n            \"group\": 1,\n            \"x\": -300\n        }\n    ],\n    \"edges\": [\n        // Your edge definitions here\n    ]\n}\n`\n</code></pre> </li> </ul> </li> </ol>"},{"location":"vis/node-enricher/#notes","title":"Notes","text":"<ul> <li>Error Handling: The script includes basic error handling for missing files and invalid JSON formats.</li> <li>Flexibility: You can specify different input and output files via command-line arguments.</li> <li>Extensibility: You can easily modify the script to add more properties or handle different conditions as needed.</li> </ul> <p>Feel free to customize the script further based on your specific requirements!</p> <p>o1-mini</p> <p>window.__oai_logHTML?window.__oai_logHTML():window.__oai_SSR_HTML=window.__oai_SSR_HTML||Date.now();requestAnimationFrame((function(){window.__oai_logTTI?window.__oai_logTTI():window.__oai_SSR_TTI=window.__oai_SSR_TTI||Date.now()}))</p> <p>ChatGPT can make mistakes. Check imp</p>"},{"location":"vis/physics-params/","title":"Physics Parameters","text":"<p>Run the MicroSim</p>"},{"location":"vis/physics-params/#prompt","title":"Prompt","text":"<pre><code>Create a vis.js program that demonstrates the different parameters in a physics model. Add horizontal sliders to change the physics parameters.\n</code></pre> <p>ChatGPT o1-preview thought for 17 seconds</p> <p>Sure! Below is a vis.js program that demonstrates different physics parameters in a network visualization. You can adjust the parameters using horizontal sliders to see how they affect the network's behavior.</p>"},{"location":"vis/physics-params/#html-and-javascript-code","title":"HTML and JavaScript Code:","text":"<p>Save the following code in an <code>index.html</code> file and open it in a web browser.</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;title&gt;vis.js Physics Parameters Demo&lt;/title&gt;\n\n  &lt;script type=\"text/javascript\" src=\"https://unpkg.com/vis-network/standalone/umd/vis-network.min.js\"&gt;&lt;/script&gt;\n  &lt;style type=\"text/css\"&gt;\n    #network {\n      width: 800px;\n      height: 600px;\n      border: 1px solid lightgray;\n      margin-bottom: 20px;\n    }\n    .slider-container {\n      margin: 10px 0;\n    }\n    .slider-label {\n      display: inline-block;\n      width: 150px;\n    }\n  &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\n&lt;div id=\"network\"&gt;&lt;/div&gt;\n\n&lt;div class=\"slider-container\"&gt;\n  &lt;label class=\"slider-label\" for=\"repulsion\"&gt;Repulsion (Node Distance):&lt;/label&gt;\n  &lt;input type=\"range\" id=\"repulsion\" min=\"50\" max=\"500\" value=\"100\" step=\"10\"&gt;\n  &lt;span id=\"repulsion-value\"&gt;100&lt;/span&gt;\n&lt;/div&gt;\n\n&lt;div class=\"slider-container\"&gt;\n  &lt;label class=\"slider-label\" for=\"gravity\"&gt;Central Gravity:&lt;/label&gt;\n  &lt;input type=\"range\" id=\"gravity\" min=\"0\" max=\"1\" value=\"0.3\" step=\"0.01\"&gt;\n  &lt;span id=\"gravity-value\"&gt;0.30&lt;/span&gt;\n&lt;/div&gt;\n\n&lt;div class=\"slider-container\"&gt;\n  &lt;label class=\"slider-label\" for=\"damping\"&gt;Damping:&lt;/label&gt;\n  &lt;input type=\"range\" id=\"damping\" min=\"0\" max=\"1\" value=\"0.09\" step=\"0.01\"&gt;\n  &lt;span id=\"damping-value\"&gt;0.09&lt;/span&gt;\n&lt;/div&gt;\n\n&lt;script type=\"text/javascript\"&gt;\n  // Create nodes and edges for the network\n  var nodes = new vis.DataSet([\n    {id: 1, label: 'Node 1'},\n    {id: 2, label: 'Node 2'},\n    {id: 3, label: 'Node 3'},\n    {id: 4, label: 'Node 4'},\n    {id: 5, label: 'Node 5'},\n    {id: 6, label: 'Node 6'},\n    {id: 7, label: 'Node 7'}\n  ]);\n\n  var edges = new vis.DataSet([\n    {from: 1, to: 2},\n    {from: 1, to: 3},\n    {from: 2, to: 4},\n    {from: 2, to: 5},\n    {from: 3, to: 6},\n    {from: 3, to: 7}\n  ]);\n\n  // Get the container element\n  var container = document.getElementById('network');\n\n  // Initial physics options\n  var physicsOptions = {\n    repulsion: {\n      centralGravity: 0.3,\n      nodeDistance: 100,\n      damping: 0.09\n    },\n    solver: 'repulsion'\n  };\n\n  // Initialize the network\n  var data = {nodes: nodes, edges: edges};\n  var options = {physics: physicsOptions};\n  var network = new vis.Network(container, data, options);\n\n  // Function to update physics options\n  function updatePhysics() {\n    network.setOptions({physics: physicsOptions});\n  }\n\n  // Event listeners for sliders\n  document.getElementById('repulsion').addEventListener('input', function () {\n    var value = parseInt(this.value);\n    document.getElementById('repulsion-value').innerText = value;\n    physicsOptions.repulsion.nodeDistance = value;\n    updatePhysics();\n  });\n\n  document.getElementById('gravity').addEventListener('input', function () {\n    var value = parseFloat(this.value).toFixed(2);\n    document.getElementById('gravity-value').innerText = value;\n    physicsOptions.repulsion.centralGravity = parseFloat(value);\n    updatePhysics();\n  });\n\n  document.getElementById('damping').addEventListener('input', function () {\n    var value = parseFloat(this.value).toFixed(2);\n    document.getElementById('damping-value').innerText = value;\n    physicsOptions.repulsion.damping = parseFloat(value);\n    updatePhysics();\n  });\n&lt;/script&gt;\n\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"vis/physics-params/#explanation","title":"Explanation:","text":"<ul> <li> <p>Nodes and Edges:</p> <ul> <li>We define a simple network with 7 nodes and connections (edges) between them.</li> <li>Nodes are labeled from \"Node 1\" to \"Node 7\".</li> <li>Edges create connections forming a small network graph.</li> </ul> </li> <li> <p>Physics Options:</p> <ul> <li>We initialize the physics options with default values:<ul> <li><code>centralGravity</code>: Attraction of nodes towards the center.</li> <li><code>nodeDistance</code>: Desired distance between nodes (affects repulsion).</li> <li><code>damping</code>: Reduces the velocity over time to stabilize the network.</li> </ul> </li> <li>We set the physics solver to <code>'repulsion'</code> for a force-directed layout.</li> <li> <p>Sliders:</p> </li> <li> <p>Three sliders allow users to adjust:</p> <ul> <li>Repulsion (Node Distance): How far apart nodes repel each other.</li> <li>Central Gravity: How strongly nodes are pulled toward the center.</li> <li>Damping: The rate at which movement slows down over time.</li> </ul> </li> <li>Each slider displays its current value next to it.</li> <li> <p>Updating Physics:</p> </li> <li> <p>When a slider is moved, an event listener updates the corresponding physics parameter.</p> </li> <li>The <code>network.setOptions()</code> method is called to apply the new physics settings.</li> <li>The network visualization updates in real-time to reflect changes.</li> <li> <p>Styling:</p> </li> <li> <p>Basic CSS styles define the size of the network container and layout of sliders.</p> </li> </ul> </li> </ul>"},{"location":"vis/physics-params/#how-to-use","title":"How to Use:","text":"<ol> <li> <p>Copy and Save the Code:</p> <ul> <li>Paste the code into a text editor and save it as <code>index.html</code>.</li> <li> <p>Open in a Web Browser:</p> </li> <li> <p>Double-click the <code>index.html</code> file to open it in your default web browser.</p> </li> <li> <p>Interact with the Sliders:</p> </li> <li> <p>Adjust the sliders for Repulsion, Central Gravity, and Damping.</p> </li> <li>Observe how the network graph rearranges itself based on the physics parameters.</li> </ul> </li> </ol>"},{"location":"vis/physics-params/#understanding-the-parameters","title":"Understanding the Parameters","text":"<ul> <li> <p>Repulsion (Node Distance):</p> <ul> <li>Higher values increase the distance nodes push away from each other.</li> <li>Lower values allow nodes to come closer together.</li> </ul> </li> <li> <p>Central Gravity:</p> <ul> <li>Higher values pull nodes towards the center more strongly.</li> <li>A value of <code>0</code> means no central gravity; nodes only interact based on repulsion.</li> </ul> </li> <li> <p>Damping:</p> <ul> <li>Controls how quickly nodes slow down after movement.</li> <li>Higher values make the network stabilize faster.</li> </ul> </li> </ul> <p>Feel free to experiment with different values to see how they affect the network's behavior. This interactive demo helps in understanding how physics parameters influence  force-directed graph layouts in vis.js.</p>"}]}